#!/usr/bin/env bash

# Declare configuration in the form of an associative array
#
# declare -g -A JIRAS_URL
# JIRAS_URL["https://my.atlassian.net"]="my/jira"

jira() {
  if [[ ${#JIRAS_URL[@]} -eq 0 ]]; then
    _jira_warning "No JIRA configuration defined"
    return
  fi

  local scope="assignee"

  OPTIND=0

  while getopts ":s:" option; do
    case "${option}" in
    s)
      scope="${OPTARG}"
      ;;

    :)
      printf "option -%s requires a value\n" "${OPTARG}" 1>&2
      return 1
      ;;

    \?)
      printf "option -%s is invalid\n" "${OPTARG}" 1>&2
      return 2
      ;;
    esac
  done

  shift $((OPTIND - 1))

  local ACTION="${1-}"
  shift

  if [[ -z ${ACTION} ]]; then
    _jira_help
    return 1
  fi

  local JIRA_DOMAIN
  JIRA_DOMAIN="$(printf "%s\n" "${!JIRAS_URL[@]}" | fzf --height=20 --ansi --reverse --select-1)"

  case ${ACTION} in
  "branch")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}" "${1-}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_info "Issue ${JIRA_ISSUE}"
    _jira_branch
    ;;

  "create")
    local JIRA_PROJECT
    JIRA_PROJECT="$(_jira_project)"

    if [[ -z ${JIRA_PROJECT} ]]; then
      return
    fi

    JIRA_PROJECT_KEY="$(printf "%s" "${JIRA_PROJECT}" | awk '{printf("%s", $2)}')"

    _jira_info "Project: ${JIRA_PROJECT_KEY}"
    JIRA_PROJECT="$(printf "%s" "${JIRA_PROJECT}" | awk '{printf("%s", $1)}')"

    local JIRA_ISSUE_TYPE
    JIRA_ISSUE_TYPE="$(_jira_issue_type "${JIRA_PROJECT}")"

    if [[ -z ${JIRA_ISSUE_TYPE} ]]; then
      return
    fi

    _jira_info "Issue Type: $(printf "%s" "${JIRA_ISSUE_TYPE}" | cut -f 2- -d ' ')"
    JIRA_ISSUE_TYPE="$(printf "%s" "${JIRA_ISSUE_TYPE}" | awk '{printf("%s", $1)}')"

    local JIRA_ISSUE_SUMMARY
    read -r -p "Summary: " JIRA_ISSUE_SUMMARY

    local JIRA_USER
    if _jira_confirm "Self assign"; then
      JIRA_USER="$(_jira_self_user)"
      _jira_info "User: ${JIRA_ISSUE_TYPE}"
    fi

    local JIRA_CREATE_ISSUE_PAYLOAD
    JIRA_CREATE_ISSUE_PAYLOAD="$(jq --compact-output --null-input \
      --arg project "${JIRA_PROJECT}" \
      --arg user "${JIRA_USER}" \
      --arg issuetype "${JIRA_ISSUE_TYPE}" \
      --arg summary "${JIRA_ISSUE_SUMMARY}" \
      '{
        fields: {
          summary: $summary,
          project: {
            id: $project
          },
          issuetype: {
            id: $issuetype
          }
        }
      }')"

    if [[ -n ${JIRA_USER-} ]]; then
      local JIRA_ASSIGNEE
      JIRA_ASSIGNEE="$(jq --null-input --arg user "${JIRA_USER}" '{fields: { assignee: {id: $user} } }')"

      JIRA_CREATE_ISSUE_PAYLOAD="$(printf "%s %s" "${JIRA_CREATE_ISSUE_PAYLOAD}" "${JIRA_ASSIGNEE}" | jq --compact-output --slurp '.[0] * .[1]')"
    fi

    local JIRA_EPIC
    JIRA_EPIC="$(_jira_epic "${JIRA_PROJECT_KEY}")"

    if [[ ${JIRA_EPIC:-None} != "None" ]]; then
      _jira_info "Epic:$(printf "%s" "${JIRA_EPIC}" | awk '{$1=""; print}')"
      JIRA_EPIC="$(printf "%s" "${JIRA_EPIC}" | awk '{printf("%s", $1)}')"

      local JIRA_PARENT_JSON
      JIRA_PARENT_JSON="$(jq --null-input --arg epic "${JIRA_EPIC}" '{fields: { parent: {id: $epic} } }')"

      JIRA_CREATE_ISSUE_PAYLOAD="$(printf "%s %s" "${JIRA_CREATE_ISSUE_PAYLOAD}" "${JIRA_PARENT_JSON}" | jq --compact-output --slurp '.[0] * .[1]')"
    fi

    local EXTRA_FIELDS_NAMES
    EXTRA_FIELDS_NAMES="$(_jira_extra_fields "${JIRA_PROJECT}" "${JIRA_ISSUE_TYPE}")"

    while true; do
      local EXTRA_FIELD_OUTPUT
      EXTRA_FIELD_OUTPUT="$(_jira_fill_extra_fields "${EXTRA_FIELDS_NAMES}")"

      if [[ -z ${EXTRA_FIELD_OUTPUT} ]]; then
        break
      fi

      JIRA_CREATE_ISSUE_PAYLOAD="$(printf "%s %s" "${JIRA_CREATE_ISSUE_PAYLOAD}" "${EXTRA_FIELD_OUTPUT}" | jq --compact-output --slurp '.[0] * .[1]')"
    done

    local JIRA_ISSUE_CREATION
    JIRA_ISSUE_CREATION="$(_jira_request "/rest/api/3/issue" --request "POST" --header "Content-Type: application/json" --data "${JIRA_CREATE_ISSUE_PAYLOAD}")"

    if [[ -n ${JIRA_ISSUE_CREATION} ]]; then
      local JIRA_ISSUE
      JIRA_ISSUE="$(printf "%s" "${JIRA_ISSUE_CREATION}" | jq --raw-output '.key')"

      _jira_info "Issue ${JIRA_ISSUE} created"

      if _jira_confirm "Open in browser"; then
        open "${JIRA_DOMAIN}/browse/${JIRA_ISSUE}"
      fi

      if _jira_confirm "Change status"; then
        _jira_transition
      fi

      if _jira_confirm "Create branch"; then
        _jira_branch
      fi

    fi

    ;;

  "print")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}" "${1-}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    printf "%s" "${JIRA_ISSUE}"
    ;;

  "summary")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}" "${1-}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_summary "${JIRA_ISSUE}"
    ;;

  "transition")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}" "${1-}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_transition "${JIRA_ISSUE}" "${2-}"
    ;;

  "url")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}" "${1-}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    printf "%s/browse/%s" "${JIRA_DOMAIN}" "${JIRA_ISSUE}"
    ;;

  *)
    _jira_help
    return 1
    ;;
  esac
}

_jira_branch() {
  if [[ $(git rev-parse --is-inside-work-tree 2>&1) != "true" ]]; then
    _jira_error "not in a git directory"
  fi

  local JIRA_BRANCH_NAME="${JIRA_ISSUE}"

  local BRANCH_PREFIX
  read -r -p "BRANCH_PREFIX=" BRANCH_PREFIX
  if [[ -n ${BRANCH_SUFFIX} ]]; then
    JIRA_BRANCH_NAME="${BRANCH_PREFIX}${JIRA_BRANCH_NAME}"
  fi

  local BRANCH_SUFFIX
  read -r -p "BRANCH_SUFFIX=" BRANCH_SUFFIX
  if [[ -n ${BRANCH_SUFFIX} ]]; then
    JIRA_BRANCH_NAME="${JIRA_BRANCH_NAME}${BRANCH_SUFFIX}"
  fi

  local CHECKOUT_OPTION=""
  if ! git rev-parse --quiet --verify "${JIRA_BRANCH_NAME}" >/dev/null 2>&1; then
    CHECKOUT_OPTION+=" -b"
  fi

  git checkout ${CHECKOUT_OPTION} "${JIRA_BRANCH_NAME}"
}

_jira_transition() {
  local JIRA_TRANSITIONS
  JIRA_TRANSITIONS="$(_jira_request "/rest/api/3/issue/${JIRA_ISSUE}/transitions" --get)"

  if [[ -z ${JIRA_TRANSITIONS} ]]; then
    return
  fi

  local JIRA_TRANSITION
  JIRA_TRANSITION="$(
    printf "%s" "${JIRA_TRANSITIONS}" | jq --raw-output '.transitions[] | .id + " " + .name' |
      fzf --height=20 --ansi --reverse --exit-0 --prompt="Status: " --select-1 --query "${2-}"
  )"

  if [[ -z ${JIRA_TRANSITION} ]]; then
    return
  fi

  local JIRA_TRANSITION_ID
  JIRA_TRANSITION_ID="$(printf "%s" "${JIRA_TRANSITION}" | awk '{printf("%s", $1)}')"

  local JIRA_TRANSITION_NAME
  JIRA_TRANSITION_NAME="$(printf "%s" "${JIRA_TRANSITION}" | awk '{$1=""; print}')"

  _jira_request "/rest/api/3/issue/${JIRA_ISSUE}/transitions" --request "POST" --header "Content-Type: application/json" --data "$(jq --null-input --compact-output --arg transition_id "${JIRA_TRANSITION_ID}" '{transition: $transition_id}')"
  _jira_info "${JIRA_ISSUE} transitionned to status${JIRA_TRANSITION_NAME}"
}

_jira_info() {
  printf -- "%b%b %b\n" "${BLUE}" "${*}" "${RESET}" 1>&2
}

_jira_warning() {
  printf -- "%b%b %b\n" "${YELLOW}" "${*}" "${RESET}" 1>&2
}

_jira_error() {
  printf -- "%b%b %b\n" "${RED}" "${*}" "${RESET}" 1>&2
}

_jira_confirm() {
  local CONFIRM_MESSAGE="${1:-Are you sure}"

  read -r -p "${CONFIRM_MESSAGE}? [y/N] " input </dev/tty

  case "${input}" in
  [yY][eE][sS] | [yY])
    return 0
    ;;

  *)
    return 1
    ;;
  esac
}

_jira_help() {
  _jira_error "Usage: jira [options?] ACTION"

  _jira_info "\nPossibles actions are                               | args\n"
  _jira_info " - branch      Switch git repository branch to ticket  | <ticket name>?"
  _jira_info " - create      Create a ticket interactively           |"
  _jira_info " - print       Print ticket ID                         | <ticket name>?"
  _jira_info " - summary     Print the summary of a ticket           | <ticket name>?"
  _jira_info " - transition  Transition ticket to another state      | <ticket name>?"
  _jira_info " - url         Print URL for ticket                    | <ticket name>?"

  _jira_info "\nPossibles options are\n"
  _jira_info " - -s Scope of tickets searched"
  _jira_info "   \t- 'assignee': only tickets on which current user is assignee (default value)"
  _jira_info "   \t- 'reporter': only tickets on which current user is reporter"
  _jira_info "   \t- 'all': no filter"
}

_jira_auth() {
  printf "Basic %s" "$(pass show "${1-}" | awk -F': ' '{ if (NR == 1) a["pass"] = $0; if ($1 == "login") a["user"] = $2; } END { printf("%s:%s",a["user"], a["pass"])}' | base64)"
}

_jira_request() {
  if [[ ${#} -lt 1 ]]; then
    _jira_error "Usage: _jira_request PATH [EXTRA_CURL_ARGS]"
    return 1
  fi

  local HEADER_OUPUT
  HEADER_OUPUT=$(mktemp)

  local JIRA_CREDENTIALS
  JIRA_CREDENTIALS="${JIRAS_URL["${JIRA_DOMAIN}"]}"

  local URL
  URL="${JIRA_DOMAIN}${1-}"
  shift 1

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(
    curl \
      --disable \
      --silent \
      --show-error \
      --location \
      --max-time 10 \
      --dump-header "${HEADER_OUPUT}" \
      --fail-with-body \
      --header "Accept: application/json" \
      --header "Authorization: $(_jira_auth "${JIRA_CREDENTIALS}")" \
      "${URL}" \
      "${@}"
  )"

  if [[ ${?} -ne 0 ]]; then
    cat "${HEADER_OUPUT}" >/dev/stderr
    printf "%s\n" "${JIRA_OUTPUT}" >/dev/stderr
    rm -f "${HEADER_OUPUT}"
    return 1
  fi

  rm -f "${HEADER_OUPUT}"
  printf "%s" "${JIRA_OUTPUT}"
}

_jira_issue() {
  local JIRA_JQL="status NOT IN (Done, Closed, Resolved)"

  if [[ ${1-} == "assignee" ]]; then
    JIRA_JQL+=" AND assignee = currentUser()"
  elif [[ ${1-} == "reporter" ]]; then
    JIRA_JQL+=" AND reporter = currentUser()"
  fi

  JIRA_JQL+=" ORDER BY updated DESC"

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(_jira_request "/rest/api/3/search" --get --data-urlencode "maxResults=200" --data-urlencode "jql=${JIRA_JQL}")"

  if [[ -z ${JIRA_OUTPUT} ]]; then
    return
  fi

  printf "%s" "${JIRA_OUTPUT}" | jq --raw-output '.issues[] | .key + " " + .fields.summary' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Issue: " --select-1 --query "${2-}" |
    awk '{printf("%s", $1)}'
}

_jira_epic() {
  local JIRA_PROJECT_NAME="${1-}"

  local JIRA_JQL="issuetype = Epic and project = ${JIRA_PROJECT_NAME}"
  JIRA_JQL+=" ORDER BY updated DESC"

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(_jira_request "/rest/api/3/search" --get --data-urlencode "maxResults=200" --data-urlencode "jql=${JIRA_JQL}")"

  if [[ -z ${JIRA_OUTPUT} ]]; then
    return
  fi

  printf "%s" "${JIRA_OUTPUT}" | jq --raw-output '.issues[] | .id + " " + .fields.summary' | awk 'BEGIN{print "None"}1' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Epic: "
}

_jira_project() {
  local JIRA_PROJECTS
  JIRA_PROJECTS="$(_jira_request "/rest/api/3/project/recent" --get)"

  if [[ -z ${JIRA_PROJECTS} ]]; then
    return
  fi

  printf "%s" "${JIRA_PROJECTS}" | jq --raw-output '.[] | .id + " " + .key + " " + .name' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Project: "
}

_jira_summary() {
  local JIRA_ISSUE_PAYLOAD
  JIRA_ISSUE_PAYLOAD="$(_jira_request "/rest/api/latest/issue/${JIRA_ISSUE}" --get)"

  if [[ -z ${JIRA_ISSUE_PAYLOAD} ]]; then
    return
  fi

  printf "%s" "${JIRA_ISSUE_PAYLOAD}" | jq --raw-output '.key + " " + .fields.summary'
}

_jira_issue_type() {
  local JIRA_PROJECT="${1}"
  shift

  local JIRA_ISSUE_TYPES
  JIRA_ISSUE_TYPES="$(_jira_request "/rest/api/3/issuetype/project" --get --data-urlencode "projectId=${JIRA_PROJECT}" --data-urlencode "level=0")"

  if [[ -z ${JIRA_ISSUE_TYPES} ]]; then
    return
  fi

  printf "%s" "${JIRA_ISSUE_TYPES}" | jq --raw-output '.[] | .id + " " + .name' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Issue Type: "
}

_jira_extra_fields() {
  local JIRA_PROJECT="${1}"
  shift

  local JIRA_ISSUE_TYPE="${1}"
  shift

  local JIRA_EXTRA_FIELDS
  JIRA_EXTRA_FIELDS="$(_jira_request "/rest/api/3/issue/createmeta" --get --data-urlencode "projectIds=${JIRA_PROJECT}" --data-urlencode "issuetypeIds=${JIRA_ISSUE_TYPE}" --data-urlencode "expand=projects.issuetypes.fields")"

  if [[ -z ${JIRA_EXTRA_FIELDS} ]]; then
    return
  fi

  printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --raw-output '.projects[].issuetypes[].fields[] | select(.key | startswith("customfield")) | select(.schema.type == "number" or .schema.type == "string" or .schema.type == "date" or .schema.type == "option")'
}

_jira_fill_extra_fields() {
  local JIRA_EXTRA_FIELDS="${1}"
  shift

  if [[ -z ${JIRA_EXTRA_FIELDS} ]]; then
    return
  fi

  local EXTRA_FIELD
  EXTRA_FIELD="$(printf '%s' "${JIRA_EXTRA_FIELDS}" | jq --raw-output '.name' | awk 'BEGIN{print "None"}1' | fzf --height=20 --ansi --reverse --exit-0 --prompt="Extra field: ")"

  if [[ ${EXTRA_FIELD:-None} == "None" ]]; then
    return
  fi

  local EXTRA_FIELD_TYPE
  EXTRA_FIELD_TYPE="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --arg name "${EXTRA_FIELD}" --raw-output 'select(.name == $name) | .schema.type')"

  local EXTRA_FIELD_VALUE

  case "${EXTRA_FIELD_TYPE}" in
  "option")
    EXTRA_FIELD_VALUE="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --arg name "${EXTRA_FIELD}" --raw-output 'select(.name == $name) | .allowedValues[] | .value' | fzf --height=20 --ansi --reverse --exit-0 --prompt="${EXTRA_FIELD}: ")"
    ;;

  "date")
    read -r -p "${EXTRA_FIELD} (in ISO format YYYY-MM-DD): " EXTRA_FIELD_VALUE
    ;;

  "string" | "number")
    read -r -p "${EXTRA_FIELD}: " EXTRA_FIELD_VALUE
    ;;
  esac

  local EXTRA_FIELD_KEY
  EXTRA_FIELD_KEY="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --arg name "${EXTRA_FIELD}" --raw-output 'select(.name == $name) | .key')"

  case "${EXTRA_FIELD_TYPE}" in
  "string" | "date")
    jq --compact-output --null-input --arg key "${EXTRA_FIELD_KEY}" --argjson value "\"${EXTRA_FIELD_VALUE}\"" '{ fields: { ($key): $value } }'
    ;;

  "option")
    jq --compact-output --null-input --arg key "${EXTRA_FIELD_KEY}" --argjson value "\"${EXTRA_FIELD_VALUE}\"" '{ fields: { ($key): {value: $value} } }'
    ;;

  "number")
    jq --compact-output --null-input --arg key "${EXTRA_FIELD_KEY}" --argjson value "${EXTRA_FIELD_VALUE}" '{ fields: { ($key): $value } }'
    ;;
  esac
}

_jira_self_user() {
  local JIRA_USER
  JIRA_USER="$(_jira_request "/rest/api/3/myself" --get)"

  if [[ -z ${JIRA_USER} ]]; then
    return
  fi

  printf "%s" "${JIRA_USER}" | jq --raw-output '.accountId'
}
