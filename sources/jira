#!/usr/bin/env bash

# Declare configuration in the form of an associative array
#
# declare -g -A JIRAS_URL
# JIRAS_URL["https://my.atlassian.net"]="my/jira"

jira() {
  if [[ ${#JIRAS_URL[@]} -eq 0 ]]; then
    _jira_warning "No JIRA configuration defined"
    return
  fi

  local scope="self"

  OPTIND=0
  while getopts ":a" option; do
    case "${option}" in
    a)
      scope="all"
      ;;
    :)
      printf "option -%s requires a value\n" "${OPTARG}" 1>&2
      return 1
      ;;
    \?)
      printf "option -%s is invalid\n" "${OPTARG}" 1>&2
      return 2
      ;;
    esac
  done

  shift $((OPTIND - 1))

  local ACTION="${1-}"
  shift

  if [[ -z ${ACTION} ]]; then
    _jira_help
    return 1
  fi

  local JIRA_DOMAIN
  JIRA_DOMAIN="$(printf "%s\n" "${!JIRAS_URL[@]}" | fzf --height=20 --ansi --reverse --select-1)"

  case ${ACTION} in
  "browse")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_info "Issue ${JIRA_ISSUE}"
    open "${JIRA_DOMAIN}/browse/${JIRA_ISSUE}"
    ;;

  "create")
    local JIRA_PROJECT
    JIRA_PROJECT="$(_jira_project)"

    if [[ -z ${JIRA_PROJECT} ]]; then
      return
    fi

    JIRA_PROJECT_KEY="$(printf "%s" "${JIRA_PROJECT}" | awk '{printf("%s", $2)}')"

    _jira_info "Project: ${JIRA_PROJECT_KEY}"
    JIRA_PROJECT="$(printf "%s" "${JIRA_PROJECT}" | awk '{printf("%s", $1)}')"

    local JIRA_ISSUE_TYPE
    JIRA_ISSUE_TYPE="$(_jira_issue_type "${JIRA_PROJECT}")"

    if [[ -z ${JIRA_ISSUE_TYPE} ]]; then
      return
    fi

    _jira_info "Issue Type: $(printf "%s" "${JIRA_ISSUE_TYPE}" | awk '{printf("%s", $2)}')"
    JIRA_ISSUE_TYPE="$(printf "%s" "${JIRA_ISSUE_TYPE}" | awk '{printf("%s", $1)}')"

    local JIRA_EPIC
    JIRA_EPIC="$(_jira_epic "${JIRA_PROJECT_KEY}")"

    if [[ -z ${JIRA_EPIC} ]]; then
      return
    fi

    _jira_info "Epic:$(printf "%s" "${JIRA_EPIC}" | awk '{$1=""; print}')"
    JIRA_EPIC="$(printf "%s" "${JIRA_EPIC}" | awk '{printf("%s", $1)}')"

    local JIRA_ISSUE_SUMMARY
    read -r -p "Summary:" JIRA_ISSUE_SUMMARY

    local JIRA_USER
    if _jira_confirm "Self assign"; then
      JIRA_USER="$(_jira_self_user)"
      _jira_info "User: ${JIRA_ISSUE_TYPE}"
    fi

    local JIRA_CREATE_ISSUE_PAYLOAD
    JIRA_CREATE_ISSUE_PAYLOAD="$(jq --compact-output --null-input \
      --arg project "${JIRA_PROJECT}" \
      --arg user "${JIRA_USER}" \
      --arg issuetype "${JIRA_ISSUE_TYPE}" \
      --arg summary "${JIRA_ISSUE_SUMMARY}" \
      --arg epic "${JIRA_EPIC}" \
      '{
        fields: {
          summary: $summary,
          project: {
            id: $project
          },
          issuetype: {
            id: $issuetype
          },
          assignee: {
            id: $user
          },
          parent: {
            id: $epic
          }
        }
      }')"

    local EXTRA_FIELD_OUTPUT="init"
    while [[ -n ${EXTRA_FIELD_OUTPUT} ]]; do
      EXTRA_FIELD_OUTPUT="$(_jira_extra_fields "${JIRA_PROJECT}" "${JIRA_ISSUE_TYPE}")"

      if [[ -n ${EXTRA_FIELD_OUTPUT} ]]; then
        JIRA_CREATE_ISSUE_PAYLOAD="$(printf "%s %s" "${JIRA_CREATE_ISSUE_PAYLOAD}" "${EXTRA_FIELD_OUTPUT}" | jq --compact-output --slurp '.[0] * .[1]')"
      fi
    done

    local JIRA_ISSUE_CREATION
    JIRA_ISSUE_CREATION="$(_jira_request "/rest/api/3/issue" --request "POST" --header "Content-Type: application/json" --data "${JIRA_CREATE_ISSUE_PAYLOAD}")"

    if [[ -n ${JIRA_ISSUE_CREATION} ]]; then
      local JIRA_ISSUE
      JIRA_ISSUE="$(printf "%s" "${JIRA_ISSUE_CREATION}" | jq --raw-output '.key')"

      _jira_info "Issue ${JIRA_ISSUE} created"

      if _jira_confirm "Open in browser"; then
        open "${JIRA_DOMAIN}/browse/${JIRA_ISSUE}"
      fi

      if _jira_confirm "Change status"; then
        _jira_transition
      fi

      if _jira_confirm "Create branch"; then
        _jira_branch
      fi

    fi

    ;;

  "branch")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_info "Issue ${JIRA_ISSUE}"
    _jira_branch
    ;;

  "transition")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    _jira_transition
    ;;

  "print")
    local JIRA_ISSUE
    JIRA_ISSUE="$(_jira_issue "${scope}")"

    if [[ -z ${JIRA_ISSUE} ]]; then
      return
    fi

    printf "%s" "${JIRA_ISSUE}"
    ;;

  *)
    _jira_help
    return 1
    ;;
  esac
}

_jira_branch() {
  if [[ $(git rev-parse --is-inside-work-tree 2>&1) != "true" ]]; then
    _jira_error "not in a git directory"
  fi

  local JIRA_BRANCH_NAME="${JIRA_ISSUE}"

  local BRANCH_PREFIX
  read -r -p "BRANCH_PREFIX=" BRANCH_PREFIX
  if [[ -n ${BRANCH_SUFFIX} ]]; then
    JIRA_BRANCH_NAME="${BRANCH_PREFIX}${JIRA_BRANCH_NAME}"
  fi

  local BRANCH_SUFFIX
  read -r -p "BRANCH_SUFFIX=" BRANCH_SUFFIX
  if [[ -n ${BRANCH_SUFFIX} ]]; then
    JIRA_BRANCH_NAME="${JIRA_BRANCH_NAME}${BRANCH_SUFFIX}"
  fi

  local CHECKOUT_OPTION=""
  if ! git rev-parse --quiet --verify "${JIRA_BRANCH_NAME}" >/dev/null 2>&1; then
    CHECKOUT_OPTION+=" -b"
  fi

  git checkout ${CHECKOUT_OPTION} "${JIRA_BRANCH_NAME}"
}

_jira_transition() {
  local JIRA_TRANSITIONS
  JIRA_TRANSITIONS="$(_jira_request "/rest/api/3/issue/${JIRA_ISSUE}/transitions" --get)"

  if [[ -z ${JIRA_TRANSITIONS} ]]; then
    return
  fi

  local JIRA_TRANSITION
  JIRA_TRANSITION="$(
    printf "%s" "${JIRA_TRANSITIONS}" | jq --raw-output '.transitions[] | .id + " - " + .name' |
      fzf --height=20 --ansi --reverse --exit-0 --prompt="Status:" |
      awk '{printf("%s", $1)}'
  )"

  if [[ -z ${JIRA_TRANSITION} ]]; then
    return
  fi

  _jira_request "/rest/api/3/issue/${JIRA_ISSUE}/transitions" --request "POST" --header "Content-Type: application/json" --data "$(jq --null-input --compact-output --arg transition_id "${JIRA_TRANSITION}" '{transition: $transition_id}')"
  _jira_info "${JIRA_ISSUE} transitionned to status ${JIRA_TRANSITION}"
}

_jira_info() {
  printf -- "%b%b %b\n" "${BLUE}" "${*}" "${RESET}" 1>&2
}

_jira_warning() {
  printf -- "%b%b %b\n" "${YELLOW}" "${*}" "${RESET}" 1>&2
}

_jira_error() {
  printf -- "%b%b %b\n" "${RED}" "${*}" "${RESET}" 1>&2
}

_jira_confirm() {
  local CONFIRM_MESSAGE="${1:-Are you sure}"

  read -r -p "${CONFIRM_MESSAGE}? [y/N] " input </dev/tty

  case "${input}" in
  [yY][eE][sS] | [yY])
    return 0
    ;;

  *)
    return 1
    ;;
  esac
}

_jira_help() {
  _jira_error "Usage: jira [options?] ACTION"

  _jira_info "\nPossibles actions are                               | args\n"
  _jira_info " - browse      Open browser for ticket                 | <ticket name>?"
  _jira_info " - branch      Switch git repository branch to ticket  | <ticket name>?"
  _jira_info " - print       Print ticket ID                         | <ticket name>?"
  _jira_info " - transition  Transition ticket to another state      | <ticket name>?"

  _jira_info "\nPossibles options are\n"
  _jira_info " - -a List tickets for all users (not just current)"
}

_jira_auth() {
  printf "Basic %s" "$(pass show "${1-}" | awk -F': ' '{ if (NR == 1) a["pass"] = $0; if ($1 == "login") a["user"] = $2; } END { printf("%s:%s",a["user"], a["pass"])}' | base64)"
}

_jira_request() {
  if [[ ${#} -lt 1 ]]; then
    _jira_error "Usage: _jira_request PATH [EXTRA_CURL_ARGS]"
    return 1
  fi

  local HEADER_OUPUT
  HEADER_OUPUT=$(mktemp)

  local JIRA_CREDENTIALS
  JIRA_CREDENTIALS="${JIRAS_URL["${JIRA_DOMAIN}"]}"

  local URL
  URL="${JIRA_DOMAIN}${1-}"
  shift 1

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(
    curl \
      --disable \
      --silent \
      --show-error \
      --location \
      --max-time 10 \
      --dump-header "${HEADER_OUPUT}" \
      --fail-with-body \
      --header "Accept: application/json" \
      --header "Authorization: $(_jira_auth "${JIRA_CREDENTIALS}")" \
      "${URL}" \
      "${@}"
  )"

  if [[ ${?} -ne 0 ]]; then
    cat "${HEADER_OUPUT}" >/dev/stderr
    rm -f "${HEADER_OUPUT}"
    return 1
  fi

  rm -f "${HEADER_OUPUT}"
  printf "%s" "${JIRA_OUTPUT}"
}

_jira_issue() {
  local JIRA_JQL="status NOT IN (Done, Closed, Resolved)"
  if [[ ${1-} == "self" ]]; then
    JIRA_JQL+=" AND assignee = currentUser()"
  fi
  JIRA_JQL+=" ORDER BY updated DESC"

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(_jira_request "/rest/api/3/search" --get --data-urlencode "maxResults=200" --data-urlencode "jql=${JIRA_JQL}")"

  if [[ -z ${JIRA_OUTPUT} ]]; then
    return
  fi

  printf "%s" "${JIRA_OUTPUT}" | jq --raw-output '.issues[] | .key + " " + .fields.summary' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Issue:" |
    awk '{printf("%s", $1)}'
}

_jira_epic() {
  local JIRA_PROJECT_NAME="${1-}"

  local JIRA_JQL="issuetype = Epic and project = ${JIRA_PROJECT_NAME}"
  JIRA_JQL+=" ORDER BY updated DESC"

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(_jira_request "/rest/api/3/search" --get --data-urlencode "maxResults=200" --data-urlencode "jql=${JIRA_JQL}")"

  if [[ -z ${JIRA_OUTPUT} ]]; then
    return
  fi

  printf "%s" "${JIRA_OUTPUT}" | jq --raw-output '.issues[] | .id + " " + .fields.summary' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Epic:"
}

_jira_project() {
  local JIRA_PROJECTS
  JIRA_PROJECTS="$(_jira_request "/rest/api/3/project/recent" --get)"

  if [[ -z ${JIRA_PROJECTS} ]]; then
    return
  fi

  printf "%s" "${JIRA_PROJECTS}" | jq --raw-output '.[] | .id + " " + .key + " " + .name' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Project:"
}

_jira_issue_type() {
  local JIRA_PROJECT="${1}"
  shift

  local JIRA_ISSUE_TYPES
  JIRA_ISSUE_TYPES="$(_jira_request "/rest/api/3/issuetype/project" --get --data-urlencode "projectId=${JIRA_PROJECT}" --data-urlencode "level=0")"

  if [[ -z ${JIRA_ISSUE_TYPES} ]]; then
    return
  fi

  printf "%s" "${JIRA_ISSUE_TYPES}" | jq --raw-output '.[] | .id + " " + .name' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Issue Type:"
}

_jira_extra_fields() {
  local JIRA_PROJECT="${1}"
  shift

  local JIRA_ISSUE_TYPE="${1}"
  shift

  local JIRA_EXTRA_FIELDS
  JIRA_EXTRA_FIELDS="$(_jira_request "/rest/api/3/issue/createmeta" --get --data-urlencode "projectIds=${JIRA_PROJECT}" --data-urlencode "issuetypeIds=${JIRA_ISSUE_TYPE}" --data-urlencode "expand=projects.issuetypes.fields")"

  if [[ -z ${JIRA_EXTRA_FIELDS} ]]; then
    return
  fi

  local EXTRA_FIELD
  EXTRA_FIELD="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --raw-output '.projects[].issuetypes[].fields[] | select(.schema.type == "number" or .schema.type == "string") | select(.key != "summary") | .name' |
    fzf --height=20 --ansi --reverse --exit-0 --prompt="Extra field:")"

  if [[ -z ${EXTRA_FIELD} ]]; then
    return
  fi

  local EXTRA_FIELD_VALUE
  read -r -p "${EXTRA_FIELD}:" EXTRA_FIELD_VALUE

  local EXTRA_FIELD_KEY
  EXTRA_FIELD_KEY="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --arg name "${EXTRA_FIELD}" --raw-output '.projects[].issuetypes[].fields[] | select(.name == $name) | .key')"

  local EXTRA_FIELD_TYPE
  EXTRA_FIELD_TYPE="$(printf "%s" "${JIRA_EXTRA_FIELDS}" | jq --arg name "${EXTRA_FIELD}" --raw-output '.projects[].issuetypes[].fields[] | select(.name == $name) | .schema.type')"

  case "${EXTRA_FIELD_TYPE}" in
  "string")
    jq --compact-output --null-input --arg key "${EXTRA_FIELD_KEY}" --argjson value "\"${EXTRA_FIELD_VALUE}\"" '{fields: { ($key): $value} }'
    ;;

  "number")
    jq --compact-output --null-input --arg key "${EXTRA_FIELD_KEY}" --argjson value "${EXTRA_FIELD_VALUE}" '{fields: { ($key): $value} }'
    ;;
  esac
}

_jira_self_user() {
  local JIRA_USER
  JIRA_USER="$(_jira_request "/rest/api/3/myself" --get)"

  if [[ -z ${JIRA_USER} ]]; then
    return
  fi

  printf "%s" "${JIRA_USER}" | jq --raw-output '.accountId'
}
