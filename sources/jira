#!/usr/bin/env bash

# Declare configuration in the form of an associative array
#
# declare -g -A JIRAS_URL
# JIRAS_URL["https://my.atlassian.net"]="my/jira"

jira() {
  if [[ ${#JIRAS_URL[@]} -eq 0 ]]; then
    printf "%bNo JIRA configuration defined%b\n" "${YELLOW}" "${RESET}"
    return
  fi

  local scope="self"

  OPTIND=0
  while getopts ":a" option; do
    case "${option}" in
    a)
      scope="all"
      ;;
    :)
      printf "option -%s requires a value\n" "${OPTARG}" >&2
      return 1
      ;;
    \?)
      printf "option -%s is invalid\n" "${OPTARG}" >&2
      return 2
      ;;
    esac
  done

  shift $((OPTIND - 1))

  local ACTION="${1:-}"
  shift

  if [[ -z ${ACTION} ]]; then
    _jira_help
    return
  fi

  local JIRA_DOMAIN
  JIRA_DOMAIN="$(printf "%s\n" "${!JIRAS_URL[@]}" | fzf --height=20 --ansi --reverse --select-1)"

  local JIRA_TICKET
  JIRA_TICKET="$(
    _jira_ticket "${scope}" |
      fzf --height=20 --ansi --reverse --select-1 --query="${1:-}" --exit-0 |
      awk '{printf("%s", $1)}'
  )"

  if [[ -z ${JIRA_TICKET:-} ]]; then
    return
  fi

  case ${ACTION} in
  "browse")
    open "${JIRA_DOMAIN}/browse/${JIRA_TICKET}"
    ;;

  "branch")
    if [[ $(git rev-parse --is-inside-work-tree 2>&1) != "true" ]]; then
      printf "%bnot in a git directory%b\n" "${RED}" "${RESET}" 1>&2
    fi

    local JIRA_BRANCH_NAME=""feat-${JIRA_TICKET}""

    local BRANCH_SUFFIX
    read -r -p "BRANCH_SUFFIX=" BRANCH_SUFFIX
    if [[ -n ${BRANCH_SUFFIX} ]]; then
      JIRA_BRANCH_NAME="${JIRA_BRANCH_NAME}${BRANCH_SUFFIX}"
    fi

    local CHECKOUT_OPTION=""
    if ! git rev-parse --quiet --verify "${JIRA_BRANCH_NAME}" >/dev/null 2>&1; then
      CHECKOUT_OPTION+=" -b"
    fi

    git checkout ${CHECKOUT_OPTION} "${JIRA_BRANCH_NAME}"
    ;;

  "transition")
    local JIRA_TRANSITIONS
    JIRA_TRANSITIONS="$(_jira_request "/rest/api/2/issue/${JIRA_TICKET}/transitions" --get)"

    if [[ -z ${JIRA_TRANSITIONS} ]]; then
      return
    fi

    local JIRA_TRANSITION
    JIRA_TRANSITION="$(
      printf "%s" "${JIRA_TRANSITIONS}" | jq -r '.transitions[] | .id + " - " + .name' |
        fzf --height=20 --ansi --reverse --exit-0 |
        awk '{printf("%s", $1)}'
    )"

    if [[ -z ${JIRA_TRANSITION} ]]; then
      return
    fi

    _jira_request "/rest/api/2/issue/${JIRA_TICKET}/transitions" --request "POST" --header "Content-Type: application/json" --data "$(jq -n -c --arg transition_id "${JIRA_TRANSITION}" '{transition: $transition_id}')"
    printf "%s transitionned to status %s\n" "${JIRA_TICKET}" "${JIRA_TRANSITION}"

    ;;

  "print")
    printf "%s" "${JIRA_TICKET}"
    ;;

  *)
    _jira_help
    ;;
  esac
}

_jira_help() {
  printf "%bUsage: jira ACTION%b\n" "${RED}" "${RESET}" 1>&2
  printf "%b\nPossibles actions are                               | args\n%b\n" "${BLUE}" "${RESET}" 1>&2
  printf "%b - browse      Open browser for ticket                 | <ticket name>?%b\n" "${BLUE}" "${RESET}" 1>&2
  printf "%b - branch      Switch git repository branch to ticket  | <ticket name>?%b\n" "${BLUE}" "${RESET}" 1>&2
  printf "%b - print       Print ticket ID                         | <ticket name>?%b\n" "${BLUE}" "${RESET}" 1>&2
  printf "%b - transition  Transition ticket to another state      | <ticket name>?%b\n" "${BLUE}" "${RESET}" 1>&2

  printf "%b\nPossibles options are\n%b\n" "${BLUE}" "${RESET}" 1>&2
  printf "%b - -a List tickets for all users (not just current)%b\n" "${BLUE}" "${RESET}" 1>&2
  return 1
}

_jira_auth() {
  printf "Basic %s" "$(pass show "${1:-}" | awk -F': ' '{ if (NR == 1) a["pass"] = $0; if ($1 == "login") a["user"] = $2; } END { printf("%s:%s",a["user"], a["pass"])}' | base64)"
}

_jira_request() {
  if [[ ${#} -lt 1 ]]; then
    printf "%bUsage: _jira_request PATH [EXTRA_CURL_ARGS]%b\n" "${RED}" "${RESET}"
    return 1
  fi

  local HEADER_OUPUT
  HEADER_OUPUT=$(mktemp -t jira_ticket)

  local JIRA_CREDENTIALS
  JIRA_CREDENTIALS="${JIRAS_URL["${JIRA_DOMAIN}"]}"

  local URL
  URL="${JIRA_DOMAIN}${1:-}"
  shift 1

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(
    curl \
      --disable \
      --silent \
      --show-error \
      --location \
      --max-time 10 \
      --dump-header "${HEADER_OUPUT}" \
      --fail-with-body \
      --header "Accept: application/json" \
      --header "Authorization: $(_jira_auth "${JIRA_CREDENTIALS}")" \
      "${URL}" \
      "${@}"
  )"

  if [[ ${?} -ne 0 ]]; then
    cat "${HEADER_OUPUT}" >/dev/stderr
    rm -f "${HEADER_OUPUT}"
    return 1
  fi

  rm -f "${HEADER_OUPUT}"
  printf "%s" "${JIRA_OUTPUT}"
}

_jira_ticket() {
  local JIRA_JQL="status NOT IN (Done, Closed, Resolved)"
  if [[ ${1:-} == "self" ]]; then
    JIRA_JQL+=" AND assignee = currentUser()"
  fi
  JIRA_JQL+=" ORDER BY updated DESC"

  local JIRA_OUTPUT
  JIRA_OUTPUT="$(_jira_request "/rest/api/2/search" --get --data-urlencode "maxResults=200" --data-urlencode "jql=${JIRA_JQL}")"

  if [[ -n ${JIRA_OUTPUT} ]]; then
    printf "%s" "${JIRA_OUTPUT}" | jq -r '.issues[] | .key + " " + .fields.summary'
  fi
}

_fzf_complete_jira() {
  if [[ ${COMP_CWORD} -eq 1 ]]; then
    mapfile -t COMPREPLY < <(compgen -W "browse branch print transition" -- "${COMP_WORDS[COMP_CWORD]}")
    return
  fi

  FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
    _jira_ticket "self"
  )
}

_fzf_complete_jira_post() {
  awk '{printf("%s", $1)}'
}

[[ -n ${BASH} ]] && complete -F _fzf_complete_jira -o default -o bashdefault jira
