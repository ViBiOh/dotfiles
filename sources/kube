#!/usr/bin/env bash

if ! command -v fzf >/dev/null 2>&1 || ! command -v yq >/dev/null 2>&1 || ! command -v kubectl >/dev/null 2>&1; then
  return
fi

export TMP_CONTEXT_LOCATION="${HOME}/.kube/contexts"

kube_clean_contexts() {
  rm -rf "${TMP_CONTEXT_LOCATION}"
}

kube() {
  local YELLOW='\033[33m'
  local BLUE='\033[0;34m'
  local RESET='\033[0m'

  _kube_print_and_run() {
    printf -- "%b%s%b\n" "${YELLOW}" "${*}" "${RESET}" 1>&2
    "${@}"
  }

  _kube_info() {
    printf -- "%b%b %b\n" "${BLUE}" "${*}" "${RESET}" 1>&2
  }

  _kube_warning() {
    printf -- "%b%b %b\n" "${YELLOW}" "${*}" "${RESET}" 1>&2
  }

  local KUBECTL_COMMAND=("kubectl")
  local KUBECTL_CONTEXT=()
  declare -a KUBECTL_CONTEXTS

  while [[ ${1-} =~ ^--context ]]; do
    if [[ ${1-} =~ ^--context= ]]; then
      KUBECTL_CONTEXTS+=("${1}")

      if [[ ${#KUBECTL_CONTEXT} -eq 0 ]]; then
        KUBECTL_CONTEXT+=("${1}")
      fi

      shift
    else
      KUBECTL_CONTEXTS+=("--context=${2}")

      if [[ ${#KUBECTL_CONTEXT} -eq 0 ]]; then
        KUBECTL_CONTEXT+=("--context=${2}")
      fi

      shift 2
    fi
  done

  if [[ ${#KUBECTL_CONTEXT} -ne 0 ]]; then
    KUBECTL_COMMAND+=("${KUBECTL_CONTEXT[@]}")
  fi

  local RESOURCE_TYPE
  local RESOURCE_NAMESPACE
  local RESOURCE_NAME

  _kube_resources() {
    local RESOURCE="${1-}"
    local QUERY="${2-}"

    if [[ -n ${RESOURCE} ]] && [[ -z ${QUERY} ]]; then
      QUERY="${RESOURCE}"
      RESOURCE=""
    fi

    if [[ -z ${RESOURCE} ]]; then
      RESOURCE="deployments.apps"
    fi

    local YAML_QUERY='.items[] | (.kind | downcase) + "/" + .metadata.namespace + "/" + .metadata.name'

    if [[ ${RESOURCE} == "ns" || ${RESOURCE} =~ ^namespaces? ]]; then
      YAML_QUERY='.items[] | (.kind | downcase) + "//" + .metadata.name'
    fi

    local KUBE_RESOURCE
    KUBE_RESOURCE="$("${KUBECTL_COMMAND[@]}" get "${RESOURCE}" --all-namespaces --output=yaml | yq eval "${YAML_QUERY}" | fzf --height=20 --ansi --reverse --select-1 --query="${QUERY}")"

    RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
    RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
    RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"
  }

  _kube_pod_labels() {
    if [[ ${RESOURCE_TYPE} =~ ^cronjobs? ]]; then
      printf "job-name in (%s)" "$("${KUBECTL_COMMAND[@]}" get jobs --namespace "${RESOURCE_NAMESPACE}" --output yaml | OWNER_NAME="${RESOURCE_NAME}" yq eval '.items[] | select(.metadata.ownerReferences[].name == strenv(OWNER_NAME)) | .metadata.name' | paste -sd, -)"
    elif [[ ${RESOURCE_TYPE} =~ ^jobs? ]]; then
      printf "job-name=%s" "${RESOURCE_NAME}"
    elif [[ ${RESOURCE_TYPE} =~ ^(daemonset|deployment|statefulset)s? ]]; then
      "${KUBECTL_COMMAND[@]}" get "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.selector.matchLabels | to_entries | .[] | .key + "=" + .value' | paste -sd, -
    else
      "${KUBECTL_COMMAND[@]}" get "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.metadata.labels | to_entries | .[] | .key + "=" + .value' | paste -sd, -
    fi
  }

  _kube_help() {
    _kube_info "Usage: kube ACTION"

    _kube_info "\nPossibles actions are                            | args\n"
    _kube_info " - context  | Switch context                      | <context name>"
    _kube_info " - desc     | Describe an object                  | <object type or deployment name> [object name]"
    _kube_info " - diff     | Run diff against multiple contexts  | <object type or deployment name> [object name]"
    _kube_info " - edit     | Edit an object                      | <object type or deployment name> [object name]"
    _kube_info " - env      | Generate .env file from deployments | <deployment name> [container name]"
    _kube_info " - forward  | Port-forward to a service           | <service name> [exposed port number] (default 4000) [service port number]"
    _kube_info " - help     | Print this help                     |"
    _kube_info " - image    | Print image name                    | <deployment name>"
    _kube_info " - info     | Print yaml output of an object      | <object type or deployment name> [object name]"
    _kube_info " - top      | Run top command                     | pod|node <object type or deployment name for pod filtering> [object name]"
    _kube_info " - log      | Tail logs                           | <object type or deployment name> [object name] <any additionnals args...>"
    _kube_info " - ns       | Change default namespace            | <namespace name>"
    _kube_info " - restart  | Perform a restart of pod            | <object type or deployment name> [object name]"
    _kube_info " - rollback | Undo a rollout                      | <object type or deployment name> [object name]"
    _kube_info " - watch    | Watch pods                          | <object type or deployment name> <object name> <any additionnals args...>"
    _kube_info " - *        | Call kubectl directly               | <any additionnals 'kubectl' args...>"
  }

  local ACTION
  if [[ ${#} -gt 0 ]]; then
    ACTION="${1}"
    shift
  fi

  case ${ACTION} in
  "context")
    local CONTEXT
    CONTEXT="$(kubectl config get-contexts --output name | fzf --height=20 --ansi --reverse --select-1 --query="${1-}")"

    if [[ -n ${CONTEXT-} ]]; then
      if [[ "$(yq eval '.current-context' "${KUBECONFIG:-${HOME}/.kube/config}")" == "${CONTEXT}" ]]; then
        _kube_info "Already on context '${CONTEXT}'"
        return
      fi

      if [[ -n ${TMUX-} ]]; then
        local CONTEXT_FILENAME
        CONTEXT_FILENAME="$(printf '%s' "${CONTEXT}" | md5)"

        if ! [[ -e "${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}" ]]; then
          mkdir -p "${TMP_CONTEXT_LOCATION}"
          cp "${KUBECONFIG:-${HOME}/.kube/config}" "${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}"
        fi

        export KUBECONFIG="${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}"
        tmux setenv KUBECONFIG "${KUBECONFIG}"
      fi

      _kube_print_and_run kubectl config use-context "${CONTEXT}"
    fi
    ;;

  "diff")
    if [[ ${#KUBECTL_CONTEXTS[@]} -lt 2 ]]; then
      _kube_warning "Diff only work with multiple contexts"
      return 1
    fi

    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      local QUERY="."
      if [[ ${RESOURCE_TYPE} =~ secrets? ]]; then
        QUERY=".data[] |= @base64d"
      fi

      declare -a DIFF_ARGS
      for context in "${KUBECTL_CONTEXTS[@]}"; do
        if [[ ${context} =~ ^--context= ]]; then
          DIFF_ARGS+=("<(kubectl ${context} get ${RESOURCE_TYPE} --namespace ${RESOURCE_NAMESPACE} ${RESOURCE_NAME} --output=yaml | yq eval --prettyPrint '\"${context}\", ${QUERY}')")
        elif ! [[ ${context} =~ ^--context ]]; then
          DIFF_ARGS+=("<(kubectl --context ${context} get ${RESOURCE_TYPE} --namespace ${RESOURCE_NAMESPACE} ${RESOURCE_NAME} --output=yaml | yq eval --prettyPrint '\"${context}\", ${QUERY}')")
        fi
      done

      eval "vimdiff -R ${DIFF_ARGS[*]}"
    fi
    ;;

  "desc" | "describe")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      _kube_print_and_run "${KUBECTL_COMMAND[@]}" describe "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}"
    fi
    ;;

  "edit")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      _kube_print_and_run "${KUBECTL_COMMAND[@]}" edit "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}"
    fi
    ;;

  "env")
    local FIRST=""
    if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
      FIRST="${1}"
      shift
    fi

    local SECOND=""
    if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
      SECOND="${1}"
      shift
    fi

    _kube_resources "${FIRST}" "${SECOND}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      if command -v kmux >/dev/null 2>&1; then
        _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" --namespace "${RESOURCE_NAMESPACE}" env "${RESOURCE_TYPE}" "${RESOURCE_NAME}" "${@}"
      else
        _kube_warning "env is only available if you have github.com/ViBiOh/kmux in your PATH"
        return 1
      fi
    fi
    ;;

  "forward")
    _kube_resources "services" "${1:- }"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      local KUBE_PORT="${3:-}"

      if [[ -z ${KUBE_PORT:-} ]]; then
        KUBE_PORT="$("${KUBECTL_COMMAND[@]}" get "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.ports[] | .targetPort' | fzf --height=20 --ansi --reverse --select-1 --prompt="Port: ")"
      fi

      if [[ -n ${KUBE_PORT-} ]]; then
        local LOCAL_PORT="${2:-4000}"

        if command -v kmux >/dev/null 2>&1; then
          _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" --namespace "${RESOURCE_NAMESPACE}" port-forward "${RESOURCE_TYPE}" "${RESOURCE_NAME}" "${LOCAL_PORT}:${KUBE_PORT}"
        else
          printf "%bForwarding %s from %s to %s%b\n" "${BLUE}" "${RESOURCE_TYPE}/${RESOURCE_NAMESPACE}/${RESOURCE_NAME}" "${LOCAL_PORT}" "${KUBE_PORT}" "${RESET}"
          _kube_print_and_run "${KUBECTL_COMMAND[@]}" port-forward --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_TYPE}/${RESOURCE_NAME}" --address "127.0.0.1" "${LOCAL_PORT}:${KUBE_PORT}"
        fi
      fi
    fi
    ;;

  "help")
    _kube_help
    ;;

  "image" | "images")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      if command -v kmux >/dev/null 2>&1; then
        _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" --namespace "${RESOURCE_NAMESPACE}" image "${RESOURCE_TYPE}" "${RESOURCE_NAME}"
      else
        _kube_print_and_run "${KUBECTL_COMMAND[@]}" get "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.template.spec.containers[].image'
      fi
    fi
    ;;

  "info")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      local QUERY="."
      if [[ ${RESOURCE_TYPE} =~ secrets? ]]; then
        QUERY=".data[] |= @base64d"
      fi

      _kube_print_and_run "${KUBECTL_COMMAND[@]}" get "${RESOURCE_TYPE}" --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval --prettyPrint "${QUERY}"
    fi
    ;;

  "top")
    local EXTRA_ARGS=()
    local TOP_SUB_COMMAND="pod"

    if [[ -n ${1-} ]] && [[ ${1-} =~ ^(pod|node)s?$ ]]; then
      TOP_SUB_COMMAND="${1}"
      shift
    fi

    if [[ ${TOP_SUB_COMMAND} =~ ^pods? ]]; then
      local FIRST=""
      if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
        FIRST="${1}"
        shift
      fi

      local SECOND=""
      if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
        SECOND="${1}"
        shift
      fi

      if [[ -n ${FIRST:-} ]]; then
        _kube_resources "${FIRST}" "${SECOND}"

        local EXTRA_ARGS=()

        if [[ -n ${RESOURCE_NAME-} ]]; then
          local PODS_LABELS
          PODS_LABELS="$(_kube_pod_labels)"

          if [[ -n ${PODS_LABELS-} ]]; then
            EXTRA_ARGS+=("--selector=${PODS_LABELS}" --namespace="${RESOURCE_NAMESPACE}")
          fi
        fi
      fi
    fi

    if [[ ${#KUBECTL_CONTEXTS} -eq 0 ]]; then
      _kube_print_and_run "kubectl" top "${TOP_SUB_COMMAND}" "${@}" "${EXTRA_ARGS[@]}"
    else
      for context in "${KUBECTL_CONTEXTS[@]}"; do
        _kube_print_and_run "kubectl" "${context}" top "${TOP_SUB_COMMAND}" "${@}" "${EXTRA_ARGS[@]}"
      done
    fi
    ;;

  "log" | "logs")
    local FIRST=""
    if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
      FIRST="${1}"
      shift
    fi

    local SECOND=""
    if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
      SECOND="${1}"
      shift
    fi

    _kube_resources "${FIRST}" "${SECOND}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      if [[ ${RESOURCE_TYPE} =~ ^(cronjob|daemonset|deployment|job|pod|namespace|service|node|statefulset)s? ]] && command -v kmux >/dev/null 2>&1; then
        _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" --namespace "${RESOURCE_NAMESPACE}" log "${RESOURCE_TYPE}" "${RESOURCE_NAME}" --since=24h "${@}"
      else
        local PODS_LABELS
        PODS_LABELS="$(_kube_pod_labels)"

        printf "%bTailing logs for %b%s%b where labels are %b%s%b\n" "${BLUE}" "${GREEN}" "${RESOURCE_TYPE}/${RESOURCE_NAMESPACE}/${RESOURCE_NAME}" "${BLUE}" "${YELLOW}" "${PODS_LABELS}" "${RESET}"

        _kube_print_and_run "${KUBECTL_COMMAND[@]}" logs --namespace "${RESOURCE_NAMESPACE}" --ignore-errors --prefix --selector="${PODS_LABELS}" --follow --since=24h "${@}"
      fi
    fi
    ;;

  "ns")
    "${KUBECTL_COMMAND[@]}" get namespaces --output=yaml | yq eval '.items[].metadata.name' | fzf --height=20 --ansi --reverse --select-1 --query="${1-}" | xargs "${KUBECTL_COMMAND[@]}" config set-context --current --namespace
    ;;

  "restart")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      if command -v kmux >/dev/null 2>&1; then
        _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" --namespace "${RESOURCE_NAMESPACE}" restart "${RESOURCE_TYPE}" "${RESOURCE_NAME}"
      else
        if [[ ${RESOURCE_TYPE} =~ ^jobs? ]]; then
          _kube_print_and_run "${KUBECTL_COMMAND[@]}" get --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_TYPE}" "${RESOURCE_NAME}" --output yaml | yq eval 'del(.spec.selector)' | yq eval 'del(.spec.template.metadata.labels)' | "${KUBECTL_COMMAND[@]}" replace --force --filename -
        else
          _kube_print_and_run "${KUBECTL_COMMAND[@]}" rollout restart --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_TYPE}" "${RESOURCE_NAME}"
        fi
      fi
    fi

    ;;

  "rollback")
    _kube_resources "${@}"

    if [[ -n ${RESOURCE_NAME-} ]]; then
      if [[ ${#KUBECTL_CONTEXTS} -eq 0 ]]; then
        _kube_print_and_run kubectl rollout undo --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_TYPE}" "${RESOURCE_NAME}"
      else
        for context in "${KUBECTL_CONTEXTS[@]}"; do
          _kube_print_and_run kubectl "${context}" rollout undo --namespace "${RESOURCE_NAMESPACE}" "${RESOURCE_TYPE}" "${RESOURCE_NAME}"
        done
      fi
    fi

    ;;

  "watch")
    if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
      local FIRST=""
      FIRST="${1}"
      shift

      local SECOND=""
      if [[ -n ${1-} ]] && ! [[ ${1-} =~ ^- ]]; then
        SECOND="${1}"
        shift
      fi

      _kube_resources "${FIRST}" "${SECOND}"
    fi

    local EXTRA_ARGS=()

    if [[ -n ${RESOURCE_NAME-} ]]; then
      local PODS_LABELS
      PODS_LABELS="$(_kube_pod_labels)"

      if [[ -n ${PODS_LABELS-} ]]; then
        EXTRA_ARGS+=("--selector=${PODS_LABELS}" --namespace="${RESOURCE_NAMESPACE}")
      fi
    fi

    if command -v kmux >/dev/null 2>&1; then
      _kube_print_and_run kmux "${KUBECTL_CONTEXTS[@]}" watch "${EXTRA_ARGS[@]}" "${@}"
    else
      _kube_print_and_run "${KUBECTL_COMMAND[@]}" get pods --watch "${EXTRA_ARGS[@]}" "${@}"
    fi
    ;;

  *)
    _kube_print_and_run "${KUBECTL_COMMAND[@]}" "${ACTION}" "${@}"

    return 1
    ;;
  esac
}

_fzf_complete_kube() {
  if [[ ${COMP_CWORD} -eq 1 ]]; then
    mapfile -t COMPREPLY < <(compgen -W "context desc diff edit env forward image info log ns restart watch --context --namespace -n" -- "${COMP_WORDS[COMP_CWORD]}")
    return
  fi

  case ${COMP_WORDS[COMP_CWORD - 1]} in
  "context" | "--context")
    FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
      kubectl config get-contexts --output name
    )
    ;;

  "forward")
    FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
      kubectl get services --all-namespaces --output=yaml | yq eval '.items[].metadata.name'
    )
    ;;

  "desc" | "describe" | "diff" | "edit" | "env" | "image" | "images" | "info" | "log" | "logs" | "restart")
    FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
      kubectl get deployments.app --all-namespaces --output=yaml | yq eval '.items[].metadata.name'
    )
    ;;

  "ns" | "-n" | "--namespace")
    FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
      kubectl get namespaces --output=yaml | yq eval '.items[].metadata.name'
    )
    ;;
  esac
}

[[ -n ${BASH} ]] && complete -F _fzf_complete_kube -o default -o bashdefault kube
