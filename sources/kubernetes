#!/usr/bin/env bash

if command -v kubectl >/dev/null 2>&1; then
  if command -v yq >/dev/null 2>&1; then
    __kube_ps1() {
      # preserve exit status
      local exit="${?}"

      local CONFIG_FILE="${KUBECONFIG:-${HOME}/.kube/config}"
      if ! [[ -e ${CONFIG_FILE} ]]; then
        return "${exit}"
      fi

      local K8S_CONTEXT
      K8S_CONTEXT="$(yq eval '.current-context' "${KUBECONFIG:-${HOME}/.kube/config}")"

      if [[ -n ${K8S_CONTEXT} ]]; then
        printf " ☸️ %s" "${K8S_CONTEXT}"
      fi

      return "${exit}"
    }
  fi

  if command -v fzf >/dev/null 2>&1 && command -v yq >/dev/null 2>&1; then
    kube() {
      _kube_resources() {
        local RESOURCE="${1:-}"
        local QUERY="${2:-}"

        if [[ -n ${RESOURCE} ]] && [[ -z ${QUERY} ]]; then
          QUERY="${RESOURCE}"
          RESOURCE=""
        fi

        if [[ -z ${RESOURCE} ]]; then
          RESOURCE="deployments.apps"
        fi

        local YAML_QUERY='.items[].metadata | .namespace + "/" + .name'

        if [[ ${RESOURCE} == "ns" || ${RESOURCE} =~ namespaces? ]]; then
          YAML_QUERY='.items[].metadata | "/" + .name'
        fi

        printf "%s/%s" "${RESOURCE}" "$(kubectl get "${RESOURCE}" --all-namespaces --output=yaml | yq eval "${YAML_QUERY}" | fzf --height=20 --ansi --reverse --select-1 --query="${QUERY}")"
      }

      _kube_help() {
        var_info "Usage: kube ACTION"

        var_info "\nPossibles actions are                            | args\n"
        var_info " - context | Switch context                      | <context name>"
        var_info " - desc    | Describe an object                  | <object type or deployment name> <object name>?"
        var_info " - edit    | Edit an object                      | <object type or deployment name> <object name>?"
        var_info " - env     | Generate .env file from deployments | <deployment name> <container name>?"
        var_info " - forward | Port-forward to a service           | <service name> <service port number>? <exposed port number>? (default 4000)"
        var_info " - help    | Print this help                     |"
        var_info " - image   | Print image name                    | <deployment name>"
        var_info " - info    | Print yaml output of an object      | <object type or deployment name> <object name>?"
        var_info " - log     | Tail logs                           | <object type or deployment name> <object name>? <any additionnals 'kubectl logs' args...>"
        var_info " - ns      | Change default namespace            | <namespace name>"
        var_info " - restart | Perform a rollout restart           | <object type or deployment name> <object name>?"
        var_info " - watch   | Watch pods                          | <any additionnals 'kubectl get pods' args...>"
        var_info " - *       | Call kubectl directly               | <any additionnals 'kubectl' args...>"
      }

      local KUBECTL_COMMAND="kubectl"
      local KUBECTL_CONTEXT=""
      if [[ ${1:-} =~ "--context=" ]]; then
        KUBECTL_CONTEXT+="${1}"
        shift
      elif [[ ${1:-} =~ "--context" && -n ${2:-} ]]; then
        KUBECTL_CONTEXT+="${1} ${2}"
        shift 2
      fi

      if [[ -n ${KUBECTL_CONTEXT} ]]; then
        KUBECTL_COMMAND+=" ${KUBECTL_CONTEXT}"
      fi

      local ACTION="${1}"
      shift

      case ${ACTION} in
      "context")
        local CONTEXT
        CONTEXT="$(kubectl config get-contexts --output name | fzf --height=20 --ansi --reverse --select-1 --query="${1:-}")"

        if [[ -n ${CONTEXT:-} ]]; then
          if [[ "$(yq eval '.current-context' "${KUBECONFIG:-${HOME}/.kube/config}")" == "${CONTEXT}" ]]; then
            var_info "Already on context '${CONTEXT}'"
            return
          fi

          if [[ -n ${TMUX:-} ]]; then
            local TMP_CONTEXT_LOCATION="${HOME}/.kube/contexts"

            local CONTEXT_FILENAME
            CONTEXT_FILENAME="$(printf '%s' "${CONTEXT}" | md5)"

            if ! [[ -e "${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}" ]]; then
              mkdir -p "${TMP_CONTEXT_LOCATION}"
              cp "${KUBECONFIG:-${HOME}/.kube/config}" "${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}"
            fi

            export KUBECONFIG="${TMP_CONTEXT_LOCATION}/${CONTEXT_FILENAME}"
            tmux setenv KUBECONFIG "${KUBECONFIG}"
          fi

          var_print_and_run "${KUBECTL_COMMAND} config use-context ${CONTEXT}"
        fi
        ;;

      "desc")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "${@}")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          var_print_and_run "${KUBECTL_COMMAND} describe ${RESOURCE_TYPE} --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_NAME}"
        fi
        ;;

      "edit")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "${@}")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          var_print_and_run "${KUBECTL_COMMAND} edit ${RESOURCE_TYPE} --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_NAME}"
        fi
        ;;

      "env")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "deployments.apps" "${1:- }")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          local KUBE_CONTAINER
          KUBE_CONTAINER="$(${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.template.spec.containers[].name' | fzf --height=20 --ansi --reverse --select-1 --query="${2:-}" --prompt="Container:")"

          local DEPLOYMENT_YAML
          DEPLOYMENT_YAML="$(mktemp)"
          ${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml >"${DEPLOYMENT_YAML}"

          KUBE_CONTAINER="${KUBE_CONTAINER}" yq eval '.spec.template.spec.containers[] | select(.name == strenv(KUBE_CONTAINER) and has("env")) | .env[] | select(has("value")) | .name + "=" + (.value | sub("[\n]", "\n"))' "${DEPLOYMENT_YAML}"

          local INLINE_REFS
          INLINE_REFS="$(KUBE_CONTAINER="${KUBE_CONTAINER}" yq eval '.spec.template.spec.containers[] | select(.name == strenv(KUBE_CONTAINER) and has("end")) | .env[] |
            (
              select((select(has("valueFrom")) | .valueFrom | has("configMapKeyRef"))) | "configmap/" + .valueFrom.configMapKeyRef.name + "/" + .valueFrom.configMapKeyRef.key,
              select((select(has("valueFrom")) | .valueFrom | has("secretKeyRef"))) | "secret/" + .valueFrom.secretKeyRef.name + "/" + .valueFrom.secretKeyRef.key
            )' "${DEPLOYMENT_YAML}")"

          if [[ -n ${INLINE_REFS:-} ]]; then
            while read -r inlineRef; do
              local INLINE_RESOURCE_TYPE
              INLINE_RESOURCE_TYPE="$(printf '%s' "${inlineRef}" | awk -F '/' '{ print $1 }')"
              local INLINE_RESOURCE_NAME
              INLINE_RESOURCE_NAME="$(printf '%s' "${inlineRef}" | awk -F '/' '{ print $2 }')"
              local INLINE_REF_KEY
              INLINE_REF_KEY="$(printf '%s' "${inlineRef}" | awk -F '/' '{ print $3 }')"

              YQ_QUERY='.data[strenv(SECRET_KEY)]'
              if [[ ${INLINE_RESOURCE_TYPE} == "secret" ]]; then
                YQ_QUERY+=' | @base64d'
              fi
              YQ_QUERY+=' | sub("[\n]", "\n")'

              ${KUBECTL_COMMAND} get "${INLINE_RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${INLINE_RESOURCE_NAME}" --output=yaml | SECRET_KEY="${INLINE_REF_KEY}" yq eval '.data[strenv(SECRET_KEY)]| @base64d | sub("[\n]", "\n")'
            done <<<"${INLINE_REFS}"
          fi

          local ENV_FROMS
          ENV_FROMS="$(KUBE_CONTAINER="${KUBE_CONTAINER}" yq eval '.spec.template.spec.containers[] | select(.name == strenv(KUBE_CONTAINER) and has("envFrom")) | .envFrom[] | to_entries | .[] | (.key | sub("Ref$", "")) + "/" + .value.name' "${DEPLOYMENT_YAML}")"

          if [[ -n ${ENV_FROMS:-} ]]; then
            while read -r envFrom; do
              local ENVFROM_RESOURCE_TYPE
              ENVFROM_RESOURCE_TYPE="$(printf '%s' "${envFrom}" | awk -F '/' '{ print $1 }')"
              local ENVFROM_RESOURCE_NAME
              ENVFROM_RESOURCE_NAME="$(printf '%s' "${envFrom}" | awk -F '/' '{ print $2 }')"

              local YQ_QUERY='.data | to_entries | .[] | .key + "=" + (.value'
              if [[ ${ENVFROM_RESOURCE_TYPE} == "secret" ]]; then
                YQ_QUERY+=' | @base64d'
              fi
              YQ_QUERY+=' | sub("[\n]", "\n"))'

              var_warning "${ENVFROM_RESOURCE_TYPE} ${RESOURCE_NAMESPACE}/${ENVFROM_RESOURCE_NAME}"
              ${KUBECTL_COMMAND} get "${ENVFROM_RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${ENVFROM_RESOURCE_NAME}" --output=yaml | yq eval "${YQ_QUERY}"
            done <<<"${ENV_FROMS}"
          fi

          local FIELD_REFS
          FIELD_REFS="$(KUBE_CONTAINER="${KUBE_CONTAINER}" yq eval '.spec.template.spec.containers[] | select(.name == strenv(KUBE_CONTAINER) and has("env")) | .env[] |
            (
              select(select(has("valueFrom")) | .valueFrom | has("fieldRef")) | .name + "@." + (.valueFrom.fieldRef.fieldPath | sub("'"'"'", "\"")),
              select(select(has("valueFrom")) | .valueFrom | has("resourceFieldRef")) | .name + "@.spec.containers[]|select(.name=\"" + .valueFrom.resourceFieldRef.containerName + "\")|.resources." + (.valueFrom.resourceFieldRef.resource|sub("'"'"'", "\""))
            )' "${DEPLOYMENT_YAML}")"

          if [[ -n ${FIELD_REFS:-} ]]; then
            local PODS_LABELS
            PODS_LABELS="$(${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.selector.matchLabels | to_entries | .[] | .key + "=" + .value' | paste -sd, -)"

            local POD_YAML
            POD_YAML="$(mktemp)"
            ${KUBECTL_COMMAND} get pods --namespace="${RESOURCE_NAMESPACE}" "--selector=${PODS_LABELS}" --output=yaml | yq eval '[.items[] | select(.status.phase == "Running")] | .[0]' >"${POD_YAML}"

            var_warning "Values from first 'Running' pod found"
            while read -r fieldRef; do
              local FIELDREF_NAME
              FIELDREF_NAME="$(printf '%s' "${fieldRef}" | awk -F '@' '{ print $1 }')"
              local FIELDREF_PATH
              FIELDREF_PATH="$(printf '%s' "${fieldRef}" | awk -F '@' '{ print $2 }')"

              printf "%s=%s\n" "${FIELDREF_NAME}" "$(yq eval "${FIELDREF_PATH}" "${POD_YAML}")"
            done <<<"${FIELD_REFS}"

            rm "${POD_YAML}"
          fi

          rm "${DEPLOYMENT_YAML}"
        fi
        ;;

      "forward")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "services" "${1:- }")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          local KUBE_PORT
          KUBE_PORT="$(${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.ports[] | .name' | fzf --height=20 --ansi --reverse --select-1 --query="${2:-}" --prompt="Port:")"

          if [[ -n ${KUBE_PORT:-} ]]; then
            local LOCAL_PORT="${3:-4000}"

            printf "%bForwarding %s from %s to %s%b\n" "${BLUE}" "${RESOURCE_TYPE}/${RESOURCE_NAMESPACE}/${RESOURCE_NAME}" "${LOCAL_PORT}" "${KUBE_PORT}" "${RESET}"
            var_print_and_run "${KUBECTL_COMMAND} port-forward --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_TYPE}/${RESOURCE_NAME} ${LOCAL_PORT}:${KUBE_PORT}"
          fi
        fi
        ;;

      "help")
        _kube_help
        ;;

      "image")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "deployments.apps" "${1:- }")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          var_print_and_run "${KUBECTL_COMMAND} get ${RESOURCE_TYPE} --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_NAME} --output=yaml | yq eval '.spec.template.spec.containers[].image'"
        fi
        ;;

      "info")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "${@}")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          local QUERY="."
          if [[ ${RESOURCE_TYPE} =~ secrets? ]]; then
            QUERY=".data[] |= @base64d"
          fi

          var_print_and_run "${KUBECTL_COMMAND} get ${RESOURCE_TYPE} --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_NAME} --output=yaml | yq eval --prettyPrint '${QUERY}'"
        fi
        ;;

      "log")
        local FIRST=""
        if [[ -n ${1:-} ]] && ! [[ ${1:-} =~ ^- ]]; then
          FIRST="${1}"
          shift
        fi

        local SECOND=""
        if [[ -n ${1:-} ]] && ! [[ ${1:-} =~ ^- ]]; then
          SECOND="${1}"
          shift
        fi

        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "${FIRST}" "${SECOND}")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          local PODS_LABELS

          if [[ ${RESOURCE_TYPE} =~ ^cronjobs? ]]; then
            PODS_LABELS="job-name in ($(${KUBECTL_COMMAND} get jobs --namespace="${RESOURCE_NAMESPACE}" --output yaml | OWNER_NAME="${RESOURCE_NAME}" yq eval '.items[] | select(.metadata.ownerReferences[].name == strenv(OWNER_NAME)) | .metadata.name' | paste -sd, -))"
          elif [[ ${RESOURCE_TYPE} =~ ^jobs? ]]; then
            PODS_LABELS="job-name=${RESOURCE_NAME}"
          elif [[ ${RESOURCE_TYPE} =~ ^deployments? ]]; then
            PODS_LABELS="$(${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.spec.selector.matchLabels | to_entries | .[] | .key + "=" + .value' | paste -sd, -)"
          else
            PODS_LABELS="$(${KUBECTL_COMMAND} get "${RESOURCE_TYPE}" --namespace="${RESOURCE_NAMESPACE}" "${RESOURCE_NAME}" --output=yaml | yq eval '.metadata.labels | to_entries | .[] | .key + "=" + .value' | paste -sd, -)"
          fi

          printf "%bTailing logs for %b%s%b where labels are %b%s%b\n" "${BLUE}" "${GREEN}" "${RESOURCE_TYPE}/${RESOURCE_NAMESPACE}/${RESOURCE_NAME}" "${BLUE}" "${YELLOW}" "${PODS_LABELS}" "${RESET}"

          if command -v kail >/dev/null 2>&1; then
            var_print_and_run "kail ${KUBECTL_CONTEXT} --ns='${RESOURCE_NAMESPACE}' --label='${PODS_LABELS}' --since=24h ${*}"
          else
            var_print_and_run "${KUBECTL_COMMAND} logs --namespace=${RESOURCE_NAMESPACE} --ignore-errors --prefix --all-containers=true --selector='${PODS_LABELS}' --follow --since=24h ${*}"
          fi
        fi
        ;;

      "ns")
        ${KUBECTL_COMMAND} get namespaces --output=yaml | yq eval '.items[].metadata.name' | fzf --height=20 --ansi --reverse --select-1 --query="${1:-}" | xargs ${KUBECTL_COMMAND} config set-context --current --namespace
        ;;

      "restart")
        local KUBE_RESOURCE
        KUBE_RESOURCE="$(_kube_resources "${@}")"

        local RESOURCE_TYPE
        RESOURCE_TYPE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $1 }')"
        local RESOURCE_NAMESPACE
        RESOURCE_NAMESPACE="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $2 }')"
        local RESOURCE_NAME
        RESOURCE_NAME="$(printf '%s' "${KUBE_RESOURCE}" | awk -F '/' '{ print $3 }')"

        if [[ -n ${RESOURCE_NAME:-} ]]; then
          if [[ ${RESOURCE_TYPE} =~ ^jobs? ]]; then
            var_print_and_run "${KUBECTL_COMMAND} get --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_TYPE} ${RESOURCE_NAME} --output yaml | yq eval 'del(.spec.selector)' | yq eval 'del(.spec.template.metadata.labels)' | ${KUBECTL_COMMAND} replace --force --filename -"
          else
            var_print_and_run "${KUBECTL_COMMAND} rollout restart --namespace=${RESOURCE_NAMESPACE} ${RESOURCE_TYPE} ${RESOURCE_NAME}"
          fi
        fi

        ;;

      "watch")
        var_print_and_run "${KUBECTL_COMMAND} get pods --watch ${*}"
        ;;

      *)
        ${KUBECTL_COMMAND} "${ACTION}" "${@}"

        return 1
        ;;
      esac
    }

    _fzf_complete_kube() {
      if [[ ${COMP_CWORD} -eq 1 ]]; then
        mapfile -t COMPREPLY < <(compgen -W "context desc edit env forward image info log ns restart watch" -- "${COMP_WORDS[COMP_CWORD]}")
        return
      fi

      case ${COMP_WORDS[COMP_CWORD - 1]} in
      "context")
        FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
          kubectl config get-contexts --output name
        )
        ;;

      "forward")
        FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
          kubectl get services --all-namespaces --output=yaml | yq eval '.items[].metadata.name'
        )
        ;;

      "desc" | "edit" | "env" | "image" | "info" | "log" | "restart")
        FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
          kubectl get deployments.app --all-namespaces --output=yaml | yq eval '.items[].metadata.name'
        )
        ;;

      "ns")
        FZF_COMPLETION_TRIGGER="" _fzf_complete --select-1 "${@}" < <(
          kubectl get namespaces --output=yaml | yq eval '.items[].metadata.name'
        )
        ;;
      esac
    }

    [[ -n ${BASH} ]] && complete -F _fzf_complete_kube -o default -o bashdefault kube
  fi

  kross() {
    _kross_help() {
      var_red "Usage: kross [options?] <context's regexp> ARGS..."

      var_info "\nPossibles options are\n"
      var_info " - -c Run alternative program than kube command (with --context arg)"
      var_info " - -k Contexts regexp selector"
    }

    if [[ ${#} -lt 1 ]]; then
      _kross_help
      return 1
    fi

    local COMMAND="kube"
    local CONTEXT_REGEXP=".*"

    OPTIND=0
    while getopts ":c:k:" option; do
      case "${option}" in
      c)
        COMMAND="${OPTARG}"
        ;;
      k)
        CONTEXT_REGEXP="${OPTARG}"
        ;;
      :)
        printf "option -%s requires a value\n" "${OPTARG}" >&2
        return 1
        ;;
      \?)
        printf "option -%s is invalid\n" "${OPTARG}" >&2
        return 2
        ;;
      *)
        _kross_help
        return 1
        ;;
      esac
    done

    shift $((OPTIND - 1))

    for ctx in $(kubectl config get-contexts --output name); do
      if ! [[ ${ctx} =~ ${CONTEXT_REGEXP} ]]; then
        continue
      fi

      tmux_split_cmd "var_print_and_run \"${COMMAND} --context '${ctx}' ${*}\""
    done
  }
fi

if command -v helm >/dev/null 2>&1 && command -v delta >/dev/null 2>&1 && command -v fzf >/dev/null 2>&1 && command -v jq >/dev/null 2>&1 && command -v yq >/dev/null 2>&1 && command -v rg >/dev/null 2>&1; then
  helm_select_chart() {
    local CHART_REPOSITORY
    CHART_REPOSITORY="$(helm repo list --output json | jq --raw-output '.[].name' | fzf --height=20 --ansi --reverse --select-1 --query="${1:-}")"
    if [[ -z ${CHART_REPOSITORY} ]]; then
      return 1
    fi

    var_info "Repository: ${CHART_REPOSITORY}"

    local CHART_NAME
    CHART_NAME="$(helm search repo "${CHART_REPOSITORY}/" --output json | jq --raw-output '.[].name' | fzf --height=20 --ansi --reverse --select-1 --query="${2:-}")"
    if [[ -z ${CHART_NAME} ]]; then
      return 1
    fi

    var_info "Chart: ${CHART_NAME}"

    local CHART_VERSION
    CHART_VERSION="$(helm search repo "${CHART_NAME}" --output json --devel --versions | jq --raw-output '.[].version' | fzf --height=20 --ansi --reverse --select-1 --query="${3:-}")"

    if [[ -z ${CHART_VERSION} ]]; then
      return 1
    fi

    var_info "Version: ${CHART_VERSION}"

    printf "%s@%s" "${CHART_NAME}" "${CHART_VERSION}"
  }

  helm_delta() {
    IFS='/' read -r -a release <<<"$(helm list --all-namespaces --output yaml | yq eval '.[] | .namespace + "/" + .name' - | fzf --height=20 --ansi --reverse)"
    if [[ -z ${release[0]:-} ]] || [[ -z ${release[1]:-} ]]; then
      return 1
    fi

    local NAMESPACE="${release[0]}"
    local NAME="${release[1]}"
    var_info "Release: ${NAMESPACE}/${NAME}"

    IFS='@' read -r -a chart <<<"$(helm_select_chart "" "" "")"
    if [[ -z ${chart[0]:-} ]] || [[ -z ${chart[1]:-} ]]; then
      return 1
    fi

    local CHART="${chart[0]}"
    local VERSION="${chart[1]}"

    extract_manifest() {
      yq eval '.manifest' - | yq eval --prettyPrint 'sortKeys(..)' -
    }

    local TEMP_FOLDER
    TEMP_FOLDER="$(mktemp -d)"

    helm status --output=yaml --namespace="${NAMESPACE}" "${NAME}" | extract_manifest >"${TEMP_FOLDER}/${NAME}_helm.yaml"
    helm upgrade --output=yaml --namespace="${NAMESPACE}" "${NAME}" "${CHART}" --version "${VERSION}" --debug --dry-run ${*} | extract_manifest >"${TEMP_FOLDER}/${NAME}_new.yaml"
    delta "${TEMP_FOLDER}/${NAME}_helm.yaml" "${TEMP_FOLDER}/${NAME}_new.yaml"
    rm -rf "${TEMP_FOLDER}"

    if var_confirm "Perform upgrade"; then
      var_print_and_run "helm upgrade --namespace=${NAMESPACE} ${NAME} ${CHART} --version ${VERSION} ${*}"
    fi
  }

  helm_crds_manifests() {
    IFS='@' read -r -a chart <<<"$(helm_select_chart "" "" "")"
    if [[ -z ${chart[0]:-} ]] || [[ -z ${chart[1]:-} ]]; then
      return 1
    fi

    local CHART="${chart[0]}"
    local VERSION="${chart[1]}"

    local CURRENT_DIR
    CURRENT_DIR="$(pwd)"

    (
      local TEMP_FOLDER
      TEMP_FOLDER="$(mktemp -d)"
      cd "${TEMP_FOLDER}" || false

      local CHART_BASENAME
      CHART_BASENAME="$(basename "${CHART}")"

      helm pull "${CHART}" --version "${VERSION}" --untar

      if [[ -d "${CHART_BASENAME}/crds/" ]]; then
        printf "%bCopying %b%s%b to current folder%b\n" "${BLUE}" "${YELLOW}" "$(find "${CHART_BASENAME}/crds" -type f -print0 | xargs -0 printf "%s, " | sed 's|, $||')" "${BLUE}" "${RESET}" 1>&2
        cp "${CHART_BASENAME}/crds/"* "${CURRENT_DIR}/"
      else
        var_warning "no crds/ folder in this chart, searching for definition..."
        rg -- "^kind: CustomResourceDefinition" "${CHART_BASENAME}/"
      fi

      rm -rf "${CHART_BASENAME}" "${TEMP_FOLDER}"
    )
  }
fi

if command -v kubeseal >/dev/null 2>&1 && command -v rg >/dev/null 2>&1; then
  kubeseal_raw() {
    local NAMESPACE
    var_shift_or_read NAMESPACE "${1:-}"
    shift || true

    local NAME
    var_shift_or_read NAME "${1:-}"
    shift || true

    local CONTENT
    var_shift_or_read CONTENT "${1:-}"
    shift || true

    local CERT=""
    CERT="$(rg --files --glob '*.{pem,crt}' | fzf --height=20 --ansi --reverse)"

    local SCOPE=""
    SCOPE="$(printf "strict\nnamespace-wide\ncluster-wide" | fzf --height=20 --ansi --reverse)"

    local SAFE_CONTENT
    SAFE_CONTENT="$(printf "%s" "${CONTENT}" | sed "s|'|\\\'|g")"

    var_print_and_run "printf '%s' $'${SAFE_CONTENT}' | kubeseal --raw --from-file=/dev/stdin --namespace='${NAMESPACE}' --name='${NAME}' --scope='${SCOPE}' --cert='${CERT}' | pbcopy"
  }
fi
