#!/usr/bin/env bash

if command -v kubectl >/dev/null 2>&1; then
  if command -v yq >/dev/null 2>&1; then
    __kube_ps1() {
      # preserve exit status
      local exit="${?}"

      local CONFIG_FILE="${KUBECONFIG:-${HOME}/.kube/config}"
      if ! [[ -e ${CONFIG_FILE} ]]; then
        return "${exit}"
      fi

      local K8S_CONTEXT
      K8S_CONTEXT="$(yq eval '.current-context' "${KUBECONFIG:-${HOME}/.kube/config}")"

      if [[ -n ${K8S_CONTEXT} ]]; then
        printf " ☸️ %s" "${K8S_CONTEXT}"
      fi

      return "${exit}"
    }
  fi

  kross() {
    _kross_help() {
      var_red "Usage: kross [options?] <context's regexp> ARGS..."

      var_info "\nPossibles options are\n"
      var_info " - -c Run alternative program than kube command (with --context arg)"
      var_info " - -k Contexts regexp selector"
    }

    if [[ ${#} -lt 1 ]]; then
      _kross_help
      return 1
    fi

    local COMMAND="kube"
    local CONTEXT_REGEXP=".*"

    OPTIND=0
    while getopts ":c:k:" option; do
      case "${option}" in
      c)
        COMMAND="${OPTARG}"
        ;;
      k)
        CONTEXT_REGEXP="${OPTARG}"
        ;;
      :)
        printf "option -%s requires a value\n" "${OPTARG}" >&2
        return 1
        ;;
      \?)
        printf "option -%s is invalid\n" "${OPTARG}" >&2
        return 2
        ;;
      *)
        _kross_help
        return 1
        ;;
      esac
    done

    shift $((OPTIND - 1))

    for ctx in $(kubectl config get-contexts --output name); do
      if ! [[ ${ctx} =~ ${CONTEXT_REGEXP} ]]; then
        continue
      fi

      tmux_split_cmd "var_print_and_run \"${COMMAND} --context '${ctx}' ${*}\""
    done
  }
fi

if command -v helm >/dev/null 2>&1 && command -v delta >/dev/null 2>&1 && command -v fzf >/dev/null 2>&1 && command -v jq >/dev/null 2>&1 && command -v yq >/dev/null 2>&1 && command -v rg >/dev/null 2>&1; then
  helm_select_chart() {
    local CHART_REPOSITORY
    CHART_REPOSITORY="$(helm repo list --output json | jq --raw-output '.[].name' | fzf --height=20 --ansi --reverse --select-1 --query="${1:-}")"
    if [[ -z ${CHART_REPOSITORY} ]]; then
      return 1
    fi

    var_info "Repository: ${CHART_REPOSITORY}"

    local CHART_NAME
    CHART_NAME="$(helm search repo "${CHART_REPOSITORY}/" --output json | jq --raw-output '.[].name' | fzf --height=20 --ansi --reverse --select-1 --query="${2:-}")"
    if [[ -z ${CHART_NAME} ]]; then
      return 1
    fi

    var_info "Chart: ${CHART_NAME}"

    local CHART_VERSION
    CHART_VERSION="$(helm search repo "${CHART_NAME}" --output json --devel --versions | jq --raw-output '.[].version' | fzf --height=20 --ansi --reverse --select-1 --query="${3:-}")"

    if [[ -z ${CHART_VERSION} ]]; then
      return 1
    fi

    var_info "Version: ${CHART_VERSION}"

    printf "%s@%s" "${CHART_NAME}" "${CHART_VERSION}"
  }

  helm_delta() {
    IFS='/' read -r -a release <<<"$(helm list --all-namespaces --output yaml | yq eval '.[] | .namespace + "/" + .name' - | fzf --height=20 --ansi --reverse)"
    if [[ -z ${release[0]:-} ]] || [[ -z ${release[1]:-} ]]; then
      return 1
    fi

    local NAMESPACE="${release[0]}"
    local NAME="${release[1]}"
    var_info "Release: ${NAMESPACE}/${NAME}"

    IFS='@' read -r -a chart <<<"$(helm_select_chart "" "" "")"
    if [[ -z ${chart[0]:-} ]] || [[ -z ${chart[1]:-} ]]; then
      return 1
    fi

    local CHART="${chart[0]}"
    local VERSION="${chart[1]}"

    extract_manifest() {
      yq eval '.manifest' - | yq eval --prettyPrint 'sortKeys(..)' -
    }

    local TEMP_FOLDER
    TEMP_FOLDER="$(mktemp -d)"

    helm status --output=yaml --namespace="${NAMESPACE}" "${NAME}" | extract_manifest >"${TEMP_FOLDER}/${NAME}_helm.yaml"
    helm upgrade --output=yaml --namespace="${NAMESPACE}" "${NAME}" "${CHART}" --version "${VERSION}" --debug --dry-run ${*} | extract_manifest >"${TEMP_FOLDER}/${NAME}_new.yaml"
    delta "${TEMP_FOLDER}/${NAME}_helm.yaml" "${TEMP_FOLDER}/${NAME}_new.yaml"
    rm -rf "${TEMP_FOLDER}"

    if var_confirm "Perform upgrade"; then
      var_print_and_run "helm upgrade --namespace=${NAMESPACE} ${NAME} ${CHART} --version ${VERSION} ${*}"
    fi
  }

  helm_crds_manifests() {
    IFS='@' read -r -a chart <<<"$(helm_select_chart "" "" "")"
    if [[ -z ${chart[0]:-} ]] || [[ -z ${chart[1]:-} ]]; then
      return 1
    fi

    local CHART="${chart[0]}"
    local VERSION="${chart[1]}"

    local CURRENT_DIR
    CURRENT_DIR="$(pwd)"

    (
      local TEMP_FOLDER
      TEMP_FOLDER="$(mktemp -d)"
      cd "${TEMP_FOLDER}" || false

      local CHART_BASENAME
      CHART_BASENAME="$(basename "${CHART}")"

      helm pull "${CHART}" --version "${VERSION}" --untar

      if [[ -d "${CHART_BASENAME}/crds/" ]]; then
        printf "%bCopying %b%s%b to current folder%b\n" "${BLUE}" "${YELLOW}" "$(find "${CHART_BASENAME}/crds" -type f -print0 | xargs -0 printf "%s, " | sed 's|, $||')" "${BLUE}" "${RESET}" 1>&2
        cp "${CHART_BASENAME}/crds/"* "${CURRENT_DIR}/"
      else
        var_warning "no crds/ folder in this chart, searching for definition..."
        rg -- "^kind: CustomResourceDefinition" "${CHART_BASENAME}/"
      fi

      rm -rf "${CHART_BASENAME}" "${TEMP_FOLDER}"
    )
  }
fi

if command -v kubeseal >/dev/null 2>&1 && command -v rg >/dev/null 2>&1; then
  kubeseal_raw() {
    local NAMESPACE
    var_shift_or_read NAMESPACE "${1:-}"
    shift || true

    local NAME
    var_shift_or_read NAME "${1:-}"
    shift || true

    local CONTENT
    var_shift_or_read CONTENT "${1:-}"
    shift || true

    local CERT=""
    CERT="$(rg --files --glob '*.{pem,crt}' | fzf --height=20 --ansi --reverse)"

    local SCOPE=""
    SCOPE="$(printf "strict\nnamespace-wide\ncluster-wide" | fzf --height=20 --ansi --reverse)"

    local SAFE_CONTENT
    SAFE_CONTENT="$(printf "%s" "${CONTENT}" | sed "s|'|\\\'|g")"

    var_print_and_run "printf '%s' $'${SAFE_CONTENT}' | kubeseal --raw --from-file=/dev/stdin --namespace='${NAMESPACE}' --name='${NAME}' --scope='${SCOPE}' --cert='${CERT}' | pbcopy"
  }
fi
