#!/usr/bin/env bash

if command -v kubectl >/dev/null 2>&1; then
  __kube_ps1() {
    # preserve exit status
    local exit="${?}"

    printf " ☸️ %s" "$(kubectl config view --minify --output=jsonpath --template='{..current-context}/{..namespace}')"

    return "${exit}"
  }

  if command -v fzf >/dev/null 2>&1; then
    kube() {
      get_kube_resources() {
        local RESOURCE="${1:-}"
        local QUERY="${2:-}"

        if [[ -n ${RESOURCE} ]] && [[ -z ${QUERY} ]]; then
          QUERY="${RESOURCE}"
          RESOURCE=""
        fi

        if [[ -z ${RESOURCE} ]]; then
          RESOURCE="deployments.apps"
        fi

        printf "%s/%s" "${RESOURCE}" "$(kubectl get "${RESOURCE}" --all-namespaces --output=json | jq -r '.items[].metadata | .namespace + "/" + .name' | fzf --height=20 --ansi --reverse -1 --query="${QUERY}")"
      }

      print_and_execute() {
        printf "%b%b%b\n" "${YELLOW}" "${@}" "${RESET}" 2>&1
        eval "${@}"
      }

      local ACTION="${1}"
      shift

      case ${ACTION} in
      "context")
        local CONTEXT
        CONTEXT="$(kubectl config get-contexts -o name | fzf --height=20 --ansi --reverse -1 --query="${1:-}")"

        if [[ -n ${CONTEXT:-} ]]; then
          KUBECONFIG=$(mktemp -t kubeconfig)
          export KUBECONFIG=${KUBECONFIG}
          cat "${HOME}/.kube/config" >>"${KUBECONFIG}"
          var_warning "kubectl config use-context '${CONTEXT}'"
          kubectl config use-context "${CONTEXT}"

          if [[ -n ${TMUX:-} ]]; then
            tmux setenv KUBECONFIG "${KUBECONFIG}"
          fi
        fi
        ;;

      "forward")
        IFS='/' read -r -a parts <<<"$(get_kube_resources "services" "${1:- }")"

        if [[ -n ${parts[1]:-} ]]; then
          local KUBE_PORT
          KUBE_PORT="$(kubectl get "${parts[0]}" --namespace="${parts[1]}" "${parts[2]}" --output=json | jq -r '.spec.ports[] | (.port|tostring) + "/" + .protocol' | fzf --height=20 --ansi --reverse -1 --query="${2:-}")"

          if [[ -n ${KUBE_PORT:-} ]]; then
            IFS='/' read -r -a ports <<<"${KUBE_PORT}"
            printf "%bForwarding %s from 4000 to %s%b\n" "${BLUE}" "${parts[0]}/${parts[1]}/${parts[2]}" "${ports[0]}" "${RESET}"
            print_and_execute "kubectl port-forward --namespace='${parts[1]}' '${parts[0]}/${parts[2]}' '4000:${ports[0]}'"
          fi
        fi
        ;;

      "image")
        IFS='/' read -r -a parts <<<"$(get_kube_resources "deployments.apps" "${1:- }")"

        if [[ -n ${parts[1]:-} ]]; then
          print_and_execute "kubectl get '${parts[0]}' --namespace='${parts[1]}' '${parts[2]}' --output=json | jq -r '.spec.template.spec.containers[].image'"
        fi
        ;;

      "info")
        IFS='/' read -r -a parts <<<"$(get_kube_resources "${@}")"

        if [[ -n ${parts[1]:-} ]]; then
          print_and_execute "kubectl get '${parts[0]}' --namespace='${parts[1]}' '${parts[2]}' --output=yaml"
        fi
        ;;

      "log" | "logs")
        local FIRST=""
        if ! [[ ${1:-} =~ ^- ]]; then
          FIRST="${1}"
          shift
        fi

        local SECOND=""
        if ! [[ ${1:-} =~ ^- ]]; then
          SECOND="${1}"
          shift
        fi

        IFS='/' read -r -a parts <<<"$(get_kube_resources "${FIRST}" "${SECOND}")"

        if [[ -n ${parts[1]:-} ]]; then
          local PODS_LABELS
          PODS_LABELS="$(kubectl get "${parts[0]}" --namespace="${parts[1]}" "${parts[2]}" --output=json | jq -r '.spec.selector.matchLabels | to_entries[] | .key + "=" + .value' | paste -sd, -)"

          printf "%bTailing logs for %b%s%b where labels are %b%s%b\n" "${BLUE}" "${GREEN}" "$(printf "%s" "${parts[@]}")" "${BLUE}" "${YELLOW}" "${PODS_LABELS}" "${RESET}"

          if command -v stern >/dev/null 2>&1; then
            print_and_execute "stern --namespace='${parts[1]}' --selector='${PODS_LABELS}' ${*}"
          else
            print_and_execute "kubectl logs --namespace='${parts[1]}' --ignore-errors --prefix --all-containers=true --selector='${PODS_LABELS}' --follow ${*}"
          fi
        fi
        ;;

      "ns")
        kubectl get namespaces --output=json | jq -r '.items[].metadata.name' | fzf --height=20 --ansi --reverse -1 --query="${1:-}" | xargs kubectl config set-context --current --namespace
        ;;

      "restart")
        IFS='/' read -r -a parts <<<"$(get_kube_resources "${@}")"

        if [[ -n ${parts[1]:-} ]]; then
          print_and_execute "kubectl rollout restart --namespace='${parts[1]}' '${parts[0]}' '${parts[2]}'"
        fi
        ;;

      "watch")
        print_and_execute "kubectl get pods --all-namespaces --watch ${*}"
        ;;

      *)
        var_error "Usage: kube ACTION"
        var_info "\nPossibles actions are                       | args\n"
        var_info " - context | Switch context                 | name query"
        var_info " - forward | Port-forward to a service      | name query, port number"
        var_info " - image   | Print image name               | name query"
        var_info " - info    | Print yaml output of an object | name query"
        var_info " - logs    | Tail logs                      | name query, additionnals 'kubectl logs' args..."
        var_info " - ns      | Change default namespace       | name query"
        var_info " - restart | Perform a rollout restart      | name query"
        var_info " - watch   | Watch pods of all namespaces   | additionnals 'kubectl get pods' args..."
        ;;
      esac
    }

    [[ -n ${BASH} ]] && complete -W "restart logs forward info image watch context ns" -o default -o bashdefault kube
  fi

  if command -v helm >/dev/null 2>&1 && command -v delta >/dev/null 2>&1; then
    helm_delta() {
      if [[ ${#} -lt 1 ]]; then
        var_error "Usage: helm_delta RELEASE_NAME [helm upgrade additionnal args...]"
        return 1
      fi

      local RELEASE_NAME="${1}"
      shift

      printf "%b" "$(helm status "${RELEASE_NAME}" --output=yaml | sed -n 's/^manifest: "//p' | sed 's/"$//')" >"/tmp/${RELEASE_NAME}_helm.yaml"
      helm upgrade --debug --dry-run "${RELEASE_NAME}" ${*} | sed '1,/^MANIFEST:$/d' | grep --invert-match '^$' >"/tmp/${RELEASE_NAME}_new.yaml"
      delta "/tmp/${RELEASE_NAME}_helm.yaml" "/tmp/${RELEASE_NAME}_new.yaml"
      rm "/tmp/${RELEASE_NAME}_helm.yaml" "/tmp/${RELEASE_NAME}_new.yaml"

      if var_confirm "Perform upgrade"; then
        var_warning "helm upgrade '${RELEASE_NAME}' ${*}"
        helm upgrade "${RELEASE_NAME}" ${*}
      fi
    }
  fi
fi

if command -v yq >/dev/null 2>&1 && command -v helm >/dev/null 2>&1; then
  get_crds_manifests() {
    local CHART_URL="${1:-$(helm repo list --output yaml | yq eval '.[].url' - | fzf --height=20 --ansi --reverse -1)}"
    shift || true

    if [[ -z ${CHART_URL} ]]; then
      return 1
    fi

    var_info "Chart URL: ${CHART_URL}"

    local CHART_INDEX_FILENAME
    CHART_INDEX_FILENAME=$(mktemp -t chartindex)
    curl --disable --silent --show-error --location --max-time 30 --output "${CHART_INDEX_FILENAME}" -- "${CHART_URL}/index.yaml"

    local CHART_NAME
    CHART_NAME="$(yq eval '.entries | keys' "${CHART_INDEX_FILENAME}" | awk '{print $2}' | fzf --height=20 --ansi --reverse -1 --query="${1:-}")"

    if [[ -z ${CHART_NAME} ]]; then
      rm "${CHART_INDEX_FILENAME}"
      return 1
    fi

    var_info "Chart name: ${CHART_NAME}"

    local CHART_VERSION
    CHART_VERSION="$(yq eval ".entries.${CHART_NAME}[] | .version" "${CHART_INDEX_FILENAME}" | fzf --height=20 --ansi --reverse -1 --query="${2:-}")"

    if [[ -z ${CHART_VERSION} ]]; then
      rm "${CHART_INDEX_FILENAME}"
      return 1
    fi

    var_info "Chart version: ${CHART_VERSION}"

    local ARCHIVE_URL
    ARCHIVE_URL="$(curl --disable --silent --show-error --location --max-time 30 -- "${CHART_URL}/index.yaml" | yq eval ".entries.${CHART_NAME}[] | select(.version == \"${CHART_VERSION}\") | .urls[0]" -)"

    if [[ -z ${ARCHIVE_URL} ]]; then
      rm "${CHART_INDEX_FILENAME}"
      return 1
    fi

    rm "${CHART_INDEX_FILENAME}"

    local CURRENT_DIR
    CURRENT_DIR="$(pwd)"

    local TEMP_DIR="/tmp"
    local ARCHIVE_FILENAME="${CHART_NAME}-${CHART_VERSION}"
    local ARCHIVE_PATH="${TEMP_DIR}/${ARCHIVE_FILENAME}.tar.gz"

    if ! [[ ${ARCHIVE_URL} =~ ^https?:// ]]; then
      ARCHIVE_URL="${CHART_URL}/${ARCHIVE_URL}"
    fi

    curl --disable --silent --show-error --location --max-time 300 -o "${ARCHIVE_PATH}" -- "${ARCHIVE_URL}"
    (
      cd "${TEMP_DIR}" || false
      mkdir -p "${ARCHIVE_FILENAME}"
      tar -xzf "${ARCHIVE_PATH}" -C "${ARCHIVE_FILENAME}"

      cp "${ARCHIVE_FILENAME}/${CHART_NAME}/crds/"* "${CURRENT_DIR}/"
      rm -rf "${ARCHIVE_PATH}" "${ARCHIVE_FILENAME}"
    )
  }
fi

if command -v kubeseal >/dev/null 2>&1; then
  kubeseal_raw() {
    if [[ ${#} -lt 3 ]]; then
      var_error "Usage: kubeseal_raw NAMESPACE NAME VALUE [kubeseal additionnal args...]"
      return 1
    fi

    local NAMESPACE=${1}
    shift
    local NAME=${1}
    shift
    local VALUE=${1}
    shift

    var_warning "printf '%s' '${VALUE}' | kubeseal --raw --from-file=/dev/stdin --namespace='${NAMESPACE}' --name '${NAME}' --scope 'namespace-wide' ${*}"
    printf "%s" "${VALUE}" | kubeseal --raw --from-file=/dev/stdin --namespace="${NAMESPACE}" --name "${NAME}" --scope "namespace-wide" ${*}
  }
fi
