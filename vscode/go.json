{
  "Golang App Pattern": {
    "prefix": "gap",
    "body": [
      "// App stores informations",
      "type App struct {",
      "\t${1:FlagName} string",
      "}",
      "",
      "// NewApp creates new App from Flags' config",
      "func NewApp(config map[string]*string) *App {",
      "\treturn &App{",
      "\t\t${1:FlagName}: *config[`${1:FlagName}`],",
      "\t}",
      "}",
      "",
      "// Flags adds flags for given prefix",
      "func Flags(prefix string) map[string]*string {",
      "\treturn map[string]*string{",
      "\t\t`${1:FlagName}`: flag.String(tools.ToCamel(fmt.Sprintf(`%s${2:FlagValue}`, prefix)), ``, `${3:FlagDesc}`),",
      "\t}",
      "}"
    ],
    "description": "Golang App Pattern"
  },
  "Golang Handler": {
    "prefix": "gh",
    "body": [
      "// Handler for request. Should be use with net/http",
      "func (a App) Handler() http.Handler {",
      "\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {",
      "\t})",
      "}"
    ],
    "description": "Golang Handler"
  },
  "Golang Pprof Handler": {
    "prefix": "gph",
    "body": [
      "if strings.HasPrefix(r.URL.Path, `/debug/pprof`) {",
      "\tif strings.HasPrefix(r.URL.Path, `/debug/pprof/cmdline`) {",
      "\t\tpprof.Cmdline(w, r)",
      "\t} else if strings.HasPrefix(r.URL.Path, `/debug/pprof/profile`) {",
      "\t\tpprof.Profile(w, r)",
      "\t} else if strings.HasPrefix(r.URL.Path, `/debug/pprof/symbol`) {",
      "\t\tpprof.Symbol(w, r)",
      "\t} else if strings.HasPrefix(r.URL.Path, `/debug/pprof/trace`) {",
      "\t\tpprof.Trace(w, r)",
      "\t} else if strings.HasPrefix(r.URL.Path, `/debug/pprof/`) {",
      "\t\tpprof.Index(w, r)",
      "\t}",
      "",
      "\treturn",
      "}"
    ],
    "description": "Golang Pprof Handler"
  },
  "Golang Test with HTTP": {
    "prefix": "gth",
    "body": [
      "func Test_${1:FuncName}(t *testing.T) {",
      "\tvar cases = []struct {",
      "\t\tintention string",
      "\t\trequest    *http.Request",
      "\t\twant       string",
      "\t\twantStatus int",
      "\t}{",
      "\t\t{",
      "\t\t\t`should work with given params`,",
      "\t\t\thttptest.NewRequest(http.MethodGet, `/`, nil),",
      "\t\t\t``,",
      "\t\t\thttp.StatusOK,",
      "\t\t},",
      "\t}",
      "",
      "\tfor _, testCase := range cases {",
      "\t\t\twriter := httptest.NewRecorder()",
      "",
      "\t\t\t${1:FuncName}(writer, testCase.request)",
      "",
      "\t\t\tif result := writer.Code; result != testCase.wantStatus {",
      "\t\t\t\tt.Errorf(\"%s\\n${1:FuncName}(%+v) = %+v, want status %+v\", testCase.intention, testCase.request, result, testCase.wantStatus)",
      "\t\t\t}",
      "",
      "\t\t\tif result, _ := request.ReadBody(writer.Result().Body); string(result) != testCase.want {",
      "\t\t\t\tt.Errorf(\"%s\\n${1:FuncName}(%+v) = %+v, want %+v\", testCase.intention, testCase.request, string(result), testCase.want)",
      "\t\t\t}",
      "\t}",
      "}"
    ],
    "description": "Golang Test with HTTP"
  },
  "Golang Test with Error": {
    "prefix": "gte",
    "body": [
      "func Test_${1:FuncName}(t *testing.T) {",
      "\tvar cases = []struct {",
      "\t\tintention string",
      "\t\tinput   string",
      "\t\twant    bool",
      "\t\twantErr error",
      "\t}{",
      "\t\t{",
      "\t\t\t`should work with given params`,",
      "\t\t\t`test`,",
      "\t\t\tfalse,",
      "\t\t\terrors.New(`Error while testing`),",
      "\t\t},",
      "\t}",
      "",
      "\tvar failed bool",
      "",
      "\tfor _, testCase := range cases {",
      "\t\tresult, err := ${1:FuncName}(testCase.input)",
      "",
      "\t\tfailed = false",
      "",
      "\t\tif err == nil && testCase.wantErr != nil {",
      "\t\t\tfailed = true",
      "\t\t} else if err != nil && testCase.wantErr == nil {",
      "\t\t\tfailed = true",
      "\t\t} else if err != nil && err.Error() != testCase.wantErr.Error() {",
      "\t\t\tfailed = true",
      "\t\t} else if result != testCase.want {",
      "\t\t\tfailed = true",
      "\t\t}",
      "",
      "\t\tif failed {",
      "\t\t\tt.Errorf(\"%s\\n${1:FuncName}(%+v) = (%+v, %+v), want (%+v, %+v)\", testCase.intention, testCase.input, result, err, testCase.want, testCase.wantErr)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Golang Test with Error"
  },
  "Golang Test": {
    "prefix": "gt",
    "body": [
      "func Test_${2:FuncName}(t *testing.T) {",
      "\tvar cases = []struct {",
      "\t\tintention string",
      "\t\tinput     string",
      "\t\twant      bool",
      "\t}{",
      "\t\t{",
      "\t\t\t`should work with given params`,",
      "\t\t\t`test`,",
      "\t\t\ttrue,",
      "\t\t},",
      "\t}",
      "",
      "\tfor _, testCase := range cases {",
      "\t\tif result := ${2:FuncName}(testCase.input); result != testCase.want {",
      "\t\t\tt.Errorf(\"%s\\n${2:FuncName}(%+v) = %+v, want %+v\", testCase.intention, testCase.input, result, testCase.want)",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Golang Test"
  }
}
