{
  "Golang Simple Test": {
    "prefix": "gotest",
    "body": [
      "import \"github.com/stretchr/testify/assert\"",
      "",
      "func Test${1:FuncName}(t *testing.T) {",
      "t.Parallel()",
      "",
      "t.Run(\"success\", func(t *testing.T) {",
      "t.Parallel()",
      "",
      "actual := ${1:FuncName}()",
      "",
      "expected := true",
      "",
      "assert.Equal(t, expected, actual)",
      "})",
      "}"
    ],
    "description": "Simple Golang Test"
  },
  "Golang Array Test": {
    "prefix": "gotestarray",
    "body": [
      "import \"github.com/stretchr/testify/assert\"",
      "",
      "func Test${1:FuncName}(t *testing.T) {",
      "t.Parallel()",
      "",
      "type args struct {",
      "content string",
      "}",
      "",
      "cases := map[string]struct {",
      "args      args",
      "want      bool",
      "}{",
      "\"simple\": {",
      "args{",
      "content: \"test\",",
      "},",
      "true,",
      "},",
      "}",
      "",
      "for intention, testCase := range cases {",
      "t.Run(intention, func(t *testing.T) {",
      "t.Parallel()",
      "",
      "actual := ${1:FuncName}(testCase.args.content)",
      "",
      "assert.Equal(t, testCase.want, actual)",
      "})",
      "}",
      "}"
    ],
    "description": "Golang Array Test"
  },
  "Golang Test Handler": {
    "prefix": "gotesthandler",
    "body": [
      "import \"github.com/stretchr/testify/assert\"",
      "",
      "func Test${1:FuncName}(t *testing.T) {",
      "t.Parallel()",
      "",
      "cases := map[string]struct {",
      "request    *http.Request",
      "want       string",
      "wantStatus int",
      "wantHeader http.Header",
      "}{",
      "\"simple\": {",
      "httptest.NewRequest(http.MethodGet, \"/\", nil),",
      "\"\",",
      "http.StatusOK,",
      "http.Header{},",
      "},",
      "}",
      "",
      "for intention, testCase := range cases {",
      "t.Run(intention, func(t *testing.T) {",
      "t.Parallel()",
      "",
      "writer := httptest.NewRecorder()",
      "${1:FuncName}(writer, testCase.request)",
      "",
      "actualStatus := writer.Code",
      "actualBody, _ := request.ReadBodyResponse(writer.Result())",
      "",
      "assert.Equal(t, testCase.wantStatus, actualStatus)",
      "assert.Equal(t, testCase.want, string(actualBody))",
      "",
      "for key := range testCase.wantHeader {",
      "assert.Equal(t, testCase.wantHeader.Get(key), writer.Header().Get(key))",
      "}",
      "})",
      "}",
      "}"
    ],
    "description": "Golang Test Handler"
  },
  "Golang Print": {
    "prefix": "goprint",
    "body": [
      "fmt.Printf(\"Type: %T, Value: %#v, String: `%s`\\n\", ${1:var}, ${1}, ${1})"
    ],
    "description": "Golang Print"
  },
  "Golang Option": {
    "prefix": "gooption",
    "body": [
      "type ${1:Object}Option func(${2:Struct}) ${2:Struct}",
      "",
      "func With${3:Name}(${4:Field} ${5:Type}) ${1:Object}Option {",
      "return func(instance ${2:Struct}) ${2:Struct} {",
      "instance.${4:Field} = ${4:Field}",
      "",
      "return instance",
      "}",
      "}"
    ],
    "description": "Golang Option"
  },
  "Golang Sort": {
    "prefix": "gosort",
    "body": [
      "// ${1:SortName} sort ${2:Struct} by ${3:Comment}",
      "type ${1:SortName} []${2:Struct}",
      "",
      "func (a ${1:SortName}) Len() int      { return len(a) }",
      "func (a ${1:SortName}) Swap(i, j int) { a[i], a[j] = a[j], a[i] }",
      "func (a ${1:SortName}) Less(i, j int) bool {",
      "return a[i].${4:Property} < a[j].${4:Property}",
      "}"
    ],
    "description": "Golang Sort"
  },
  "Golang Benchmark": {
    "prefix": "gobench",
    "body": [
      "func Benchmark${1:FuncName}(b *testing.B) {",
      "b.ResetTimer()",
      "for i := 0; i < b.N; i++ {",
      "${1:FuncName}()",
      "}",
      "}"
    ],
    "description": "Golang Benchmark"
  },
  "Golang Mock": {
    "prefix": "gomock",
    "body": [
      "type mocks${1:Instance} struct {",
      "${2:Field} *mocks.${3:FieldType}",
      "}",
      "",
      "func initMocks${1:Instance}(t *testing.T) (${1:Instance}, mocks${1:Instance}) {",
      "t.Helper()",
      "",
      "ctrl := gomock.NewController(t)",
      "",
      "${2:Field} := mocks.New${3:FieldType}(ctrl)",
      "",
      "return New${1:Instance}(${2:Field}), mocks${1:Instance}{",
      "${2:Field}:   ${2:Field},",
      "}",
      "}"
    ],
    "description": "Golang Mock"
  },
  "Golang App": {
    "prefix": "goapp",
    "body": [
      "type Service struct {",
      "${1:FlagName} string",
      "}",
      "",
      "type Config struct {",
      "${1:FlagName} string",
      "}",
      "",
      "func Flags(fs *flag.FlagSet, prefix string, overrides ...flags.Override) *Config {",
      "var config Config",
      "",
      "flags.New(\"${2:FlagValue}\", \"${3:FlagDesc}\").Prefix(prefix).DocPrefix(\"{4:FlagPrefix}\").StringVar(fs, &config.${1:FlagName}, \"\", overrides)",
      "",
      "return &config",
      "}",
      "",
      "func New(config *Config) Service {",
      "return Service{",
      "${1:FlagName}: config.${1:FlagName},",
      "}",
      "}"
    ],
    "description": "Golang App"
  },
  "Javascript Print": {
    "prefix": "jsprint",
    "body": ["console.log('${1:var}', typeof ${1}, ${1});"],
    "description": "Javascript Print"
  },
  "Bash Main": {
    "prefix": "bashmain",
    "body": [
      "#!/usr/bin/env bash",
      "",
      "set -o nounset -o pipefail -o errexit",
      "",
      "if [[ \\${TRACE:-0} == \"1\" ]]; then",
      "  set -o xtrace",
      "fi",
      "",
      "script_dir() {",
      "  local FILE_SOURCE=\"\\${BASH_SOURCE[0]}\"",
      "",
      "  if [[ -L \\${FILE_SOURCE} ]]; then",
      "    dirname \"\\$(readlink \"\\${FILE_SOURCE}\")\"",
      "  else",
      "    (",
      "      cd \"\\$(dirname \"\\${FILE_SOURCE}\")\" && pwd",
      "    )",
      "  fi",
      "}",
      "",
      "main() {",
      "}",
      "",
      "main \"\\${@}\""
    ],
    "description": "Bash Main"
  },
  "Bash Loop": {
    "prefix": "bashloop",
    "body": [
      "while IFS= read -r -d '' file; do",
      "  printf \"%s\" \"\\${file}\"",
      "done < <(find . -type f -name '*' -print0)"
    ],
    "description": "Bash Loop"
  },
  "Bash Option": {
    "prefix": "bashoption",
    "body": [
      "local ${1:VarName}",
      "",
      "OPTIND=0",
      "while getopts \":${2:OptName}:\" option; do",
      "  case \"\\${option}\" in",
      "  ${2:OptName})",
      "    ${1:VarName}=\"\\${OPTARG}\"",
      "    ;;",
      "  :)",
      "    printf \"option -%s requires a value\\n\" \"\\${OPTARG}\" 1>&2",
      "    return 1",
      "    ;;",
      "  \\?)",
      "    printf \"option -%s is invalid\\n\" \"\\${OPTARG}\" 1>&2",
      "    return 2",
      "    ;;",
      "  esac",
      "done",
      "",
      "shift \\$((OPTIND - 1))"
    ],
    "description": "Bash Option"
  }
}
